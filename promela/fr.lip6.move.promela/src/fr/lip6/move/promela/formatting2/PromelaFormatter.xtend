/*
 * generated by Xtext 2.11.0
 */
package fr.lip6.move.promela.formatting2

import com.google.inject.Inject
import fr.lip6.move.promela.promela.DefineMacro
import fr.lip6.move.promela.promela.InitProcess
import fr.lip6.move.promela.promela.MTypeDef
import fr.lip6.move.promela.promela.Never
import fr.lip6.move.promela.promela.ProcessDefinition
import fr.lip6.move.promela.promela.PromelaSpecification
import fr.lip6.move.promela.promela.Trace
import fr.lip6.move.promela.promela.TypeDef
import fr.lip6.move.promela.promela.VariableDeclaration
import fr.lip6.move.promela.services.PromelaGrammarAccess
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument

class PromelaFormatter extends AbstractFormatter2 {
	
	@Inject extension PromelaGrammarAccess

	def dispatch void format(PromelaSpecification promelaSpecification, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (DefineMacro defineMacro : promelaSpecification.getMacros()) {
			defineMacro.format;
		}
		for (MTypeDef mTypeDef : promelaSpecification.getMtypes()) {
			mTypeDef.format;
		}
		for (TypeDef typeDef : promelaSpecification.getUserTypes()) {
			typeDef.format;
		}
		for (VariableDeclaration variableDeclaration : promelaSpecification.getGlobalVariables()) {
			variableDeclaration.format;
		}
		for (ProcessDefinition processDefinition : promelaSpecification.getProcesses()) {
			processDefinition.format;
		}
		for (Never never : promelaSpecification.getNevers()) {
			never.format;
		}
		for (Trace trace : promelaSpecification.getTraces()) {
			trace.format;
		}
	}

	def dispatch void format(InitProcess initProcess, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		initProcess.getCorps.format;
	}
	
	// TODO: implement for NamedProcess, Active, Priority, Constraint, Run, Never, Trace, Sequence, Send, Receive, Assignment, LabeledInstruction, LocalBlock, Selection, Iteration, For, Atomic, Assert, Printf, Printm, MemVariable, TabRef, ChanVariable, ChanInitialize, SendArgs, Eval, CapacityPoll, Length, ReceiveArgs, ChannelExclusiveAssertion, MTypeDef, TypeDef, StructField, Select, Or, And, Not, Comparison, BinaryIntExpression, CasualExpression, Poll, Condition, StructRef, BitComplement, UnaryMinus
}
// DAMMIT ! we lost he formatting effort made below when "upgrading" to 2.9+ Xtext
// workload to upgrade is proportionaol to DSL size...

//class PromelaFormatter extends AbstractDeclarativeFormatter {
//
////	@Inject extension PromelaGrammarAccess
//	
//		// @Inject extension PromelaGrammarAccess
//
//	override protected void configureFormatting(FormattingConfig c) {
//
//		var PromelaGrammarAccess pga = getGrammarAccess() as PromelaGrammarAccess
//		c.setAutoLinewrap(250) // 250 caractères par ligne maximum
//		configure(c, pga)
//	}
//
//	def protected void configure(FormattingConfig c, PromelaGrammarAccess pga) {
//
//		configureKeyWords(c, pga);
//		configureNamedProcess(c, pga.namedProcessAccess)
//		configuredInitProcess(c, pga.initProcessAccess)
//		configureSelection(c, pga.selectionAccess)
//		configureIteration(c, pga.iterationAccess)
//		configureFor(c, pga.forAccess)
//		configureChanInit(c, pga.chanInitializeAccess)
//		configureAtomic(c, pga.atomicAccess)
//			
//		// format define
//		c.setLinewrap().after(pga.defineIntMacroRule)
//		c.setNoSpace().before(pga.defineIntMacroRule)
//
//		// comments
//		c.setLinewrap(0, 1, 2).before(pga.getSL_COMMENTRule())
//		c.setLinewrap(0, 1, 2).before(pga.getML_COMMENTRule())
//		c.setLinewrap(0, 1, 1).after(pga.getML_COMMENTRule())
//
//	}
//
//	def protected void configureKeyWords(FormattingConfig c, PromelaGrammarAccess pga) {
//		// delete spaces before , and ;
//		for (Keyword comma : pga.findKeywords(",")) {
//			c.setNoSpace().before(comma)
//			c.setSpace(" ").after(comma)
//		}
//
//		for (Keyword equal : pga.findKeywords("=")) {
//			c.setSpace(" ").before(equal)
//			c.setSpace(" ").after(equal)
//		}
//
//		for (Keyword semicolon : pga.findKeywords(";")) {
//			c.setNoSpace().before(semicolon)
//			c.setLinewrap().after(semicolon)
//		}
//
//		// ici pb si on a une flèche je ne veux pas retourner à la ligne
//		// si je rajoute les deux lignes suivantes, par contre, pb car pas de retour à la ligne après tous les ;
//		// c.setNoLinewrap().after(pga.getSEPAccess().getHyphenMinusGreaterThanSignKeyword_0_0());
//		// c.setLinewrap().after(pga.getSEPAccess().getSemicolonKeyword_0_1());
//		c.setNoSpace().before(pga.SEPRule)
//		c.setLinewrap().after(pga.SEPRule)
//
//		// Je laisse cet exemple pour les pairs car il peut être utile plus tard, sait-on jamais
//		// for (Pair<Keyword,Keyword> pair : pga.findKeywordPairs("{","}")) {
//		//
//		// c.setSpace("\n").after(pair.getFirst());
//		// c.setSpace("\n").before(pair.getSecond());
//		// }
//	}
//
//	def public void configureNamedProcess(FormattingConfig c,
//			NamedProcessElements nel) {
//		// format NamedProcess
//		c.setLinewrap(2).before(nel.rule)
//		c.setSpace(" ").before(nel.leftCurlyBracketKeyword_8)
//		c.setLinewrap().after(nel.leftCurlyBracketKeyword_8)
//		c.setLinewrap().after(nel.rightCurlyBracketKeyword_10)
//		c.setLinewrap().before(nel.rightCurlyBracketKeyword_10)
//		c.setIndentation(nel.leftCurlyBracketKeyword_8,
//				nel.rightCurlyBracketKeyword_10)
//
//	}
//
//	def protected void configuredInitProcess(FormattingConfig c, InitProcessElements ip) {
//		c.setLinewrap(2).before(ip.rule)
//		c.setSpace(" ").before(ip.leftCurlyBracketKeyword_2)
//		c.setLinewrap().after(ip.leftCurlyBracketKeyword_2)
//		c.setLinewrap().after(ip.rightCurlyBracketKeyword_4)
//		c.setLinewrap().before(ip.rightCurlyBracketKeyword_4)
//		c.setIndentation(ip.leftCurlyBracketKeyword_2,
//				ip.rightCurlyBracketKeyword_4)
//	}
//
//	def protected void configureSelection(FormattingConfig c, SelectionElements sel) {
//		c.setLinewrap().after(sel.ifKeyword_0)
//		c.setLinewrap().after(sel.fiKeyword_4)
//		c.setLinewrap().before(sel.fiKeyword_4)
//		c.setIndentation(sel.ifKeyword_0, sel.fiKeyword_4)
//		c.setLinewrap().before(sel.colonColonKeyword_2_0)
//		c.setLinewrap().before(sel.colonColonKeyword_3_0)
//	}
//
//	def protected void configureIteration(FormattingConfig c, IterationElements ie) {
//		c.setLinewrap().after(ie.doKeyword_0)
//		c.setLinewrap().after(ie.odKeyword_4)
//		c.setLinewrap().before(ie.odKeyword_4)
//		c.setIndentation(ie.doKeyword_0, ie.odKeyword_4)
//		c.setLinewrap().before(ie.colonColonKeyword_2_0)
//		c.setLinewrap().before(ie.colonColonKeyword_3_0)
//	}
//
//	def protected void configureFor(FormattingConfig c, ForElements fe) {
//		c.setNoSpace().after(fe.leftParenthesisKeyword_1)
//		c.setNoSpace().before(fe.rightParenthesisKeyword_4)
//		c.setLinewrap().after(fe.leftCurlyBracketKeyword_5)
//		c.setLinewrap().before(fe.rightCurlyBracketKeyword_7)
//		c.setIndentation(fe.leftCurlyBracketKeyword_5,
//				fe.rightCurlyBracketKeyword_7)
//	}
//
//	def protected void configureChanInit(FormattingConfig c, ChanInitializeElements cie) {
//		c.setSpace(" ").after(cie.leftSquareBracketKeyword_0)
//		c.setSpace(" ").before(cie.rightSquareBracketKeyword_2)
//		c.setSpace(" ").after(cie.leftCurlyBracketKeyword_4)
//		c.setSpace(" ").before(cie.rightCurlyBracketKeyword_7)
//	}
//	
//	def protected void configureAtomic(FormattingConfig c, AtomicElements ae){
//		c.setLinewrap().after(ae.rightCurlyBracketKeyword_4)
//		c.setLinewrap().after(ae.leftCurlyBracketKeyword_2)
//	}
//// It's usually a good idea to activate the following three statements.
//// They will add and preserve newlines around comments
////		c.setLinewrap(0, 1, 2).before(SL_COMMENTRule)
////		c.setLinewrap(0, 1, 2).before(ML_COMMENTRule)
////		c.setLinewrap(0, 1, 1).after(ML_COMMENTRule)
//	
//}