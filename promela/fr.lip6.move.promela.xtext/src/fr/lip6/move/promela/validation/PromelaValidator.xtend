/*
 * generated by Xtext
 */
package fr.lip6.move.promela.validation

import fr.lip6.move.promela.promela.Assignment
import fr.lip6.move.promela.promela.AssignmentOperators
import fr.lip6.move.promela.promela.Atomic
import fr.lip6.move.promela.promela.AtomicRef
import fr.lip6.move.promela.promela.Break
import fr.lip6.move.promela.promela.DefineIntMacro
import fr.lip6.move.promela.promela.Expression
import fr.lip6.move.promela.promela.Goto
import fr.lip6.move.promela.promela.Instruction
import fr.lip6.move.promela.promela.Iteration
import fr.lip6.move.promela.promela.LiteralConstant
import fr.lip6.move.promela.promela.MemVariable
import fr.lip6.move.promela.promela.Poll
import fr.lip6.move.promela.promela.Printf
import fr.lip6.move.promela.promela.PromelaPackage
import fr.lip6.move.promela.promela.PromelaSpecification
import fr.lip6.move.promela.promela.Receive
import fr.lip6.move.promela.promela.Send
import fr.lip6.move.promela.promela.Sequence
import fr.lip6.move.promela.promela.Skip
import fr.lip6.move.promela.promela.Step
import fr.lip6.move.promela.promela.TabRef
import fr.lip6.move.promela.promela.UnaryMinus
import fr.lip6.move.promela.promela.VariableDeclaration
import java.util.regex.Pattern
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.common.util.TreeIterator
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check
import fr.lip6.move.promela.promela.Reference

/**
 * Promela validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class PromelaValidator extends AbstractPromelaValidator {

	//Error codes:
	public static val PROMELA_GOTO_DEADCODE = "100"
	public static val PROMELA_UNUSED_VARIABLE = "101"
	public static val PROMELA_MACRO_UPPERCASE = "102"
	public static val PROMELA_DOUBLE_VARIABLE = "103"
	public static val PROMELA_INDEX_OUT_OF_BOUND = "104"
	public static val PROMELA_STEP_SKIP = "105"

	@Check
	def checkBreakIsInLoop(Break b) {
		if (!inLoop(b))
			warning('Break only in do statement', b, null, -1)
	}

	@Check
	def checkSkipIsInLoop(Skip s) {
		if (!inLoop(s))
			warning('Skip only in do statement', s, null, -1)
	}

	def private boolean inLoop(EObject e) {
		var EObject tmp = e.eContainer

		// Note: Val:binding. var: variable
		while (!(tmp instanceof PromelaSpecification)) {
			if (tmp instanceof Iteration)
				return true

			tmp = tmp.eContainer
		}
		return false
	}

	def private boolean foundRef(VariableDeclaration v, TreeIterator<EObject> tree) {
		while (tree.hasNext) {
			var next = tree.next
			if (next instanceof AtomicRef) {
				if ((next as AtomicRef).ref.name == v.name) {
					return true
				}
			} else if (next.eAllContents != null) {
				if (foundRef(v, next.eAllContents)) {
					return true
				}
			}
		}
		return false
	}

	@Check
	def void checkUnusedVariables(VariableDeclaration v) {
		val parent = v.eContainer()
		val scope = parent.eAllContents
		var found = foundRef(v, scope)
		if (found == false) {
			warning("This variable is not used !", v, null, PROMELA_UNUSED_VARIABLE)
		}
	}

	@Check
	def void checkNoStatementAfterGoto(Goto goto) {

		val statements = (goto.eContainer().eGet(goto.eContainmentFeature()) as EList<Step>);
		var index = statements.indexOf(goto);
		if (!(statements.last.identityEquals(goto))) {
			warning('Dead code: the code after a goto instruction is unreachable', statements.get(index + 1), null,
				PROMELA_GOTO_DEADCODE)
		}
	}

	@Check
	def checkMacroUpcase(DefineIntMacro m) {
		if (m.name.toUpperCase != m.name)
			warning('Macro name should be in upcase letters', m, null, PROMELA_MACRO_UPPERCASE, m.name)
	}

	@Check 
	def void checkNoDuplicatesVariable(VariableDeclaration vd) {

		val duplicate = (vd.eContainer().eGet(vd.eContainmentFeature()) as EList<Step>);
		duplicate.forEach [
			if (it instanceof VariableDeclaration) {
				if (((it as VariableDeclaration).name == vd.name) && (it != vd)) {
					warning("Duplicate variable declaration '", vd, null, PROMELA_DOUBLE_VARIABLE, vd.name)
				}
			}
		]
	}

	@Check
	def void checkIndexOutOfBound(TabRef arrayVarRef) {
		val tab = (arrayVarRef.ref as AtomicRef).ref as MemVariable
		if (arrayVarRef.index instanceof UnaryMinus) {
			warning("Index Out Of Bound: you can't put a negative value here '", arrayVarRef, null,
				PROMELA_INDEX_OUT_OF_BOUND, tab.name)
		} else if (arrayVarRef.index instanceof LiteralConstant) {
			if ((tab.length as LiteralConstant).value < (arrayVarRef.index as LiteralConstant).value) {
				warning("Index Out Of Bound: the array isn't as big '", arrayVarRef, null,
					PROMELA_INDEX_OUT_OF_BOUND, tab.name)
			}
		}
	}

@Check
	def checkPrintfArgs(Printf print) {
		var count = 0
		val s = print.chaine
		var EList<Expression> v = print.args
		var p = Pattern.compile("%[decoux]")
		val matcher = p.matcher(s)

		while (matcher.find)
			count = count + 1

		if (count != v.size) {

			error('''The number of arguments does not match the expecting number:  expected «count», found «v.size»''',
				PromelaPackage.Literals.PRINTF__ARGS)
		}
	}

@Check
	def checkNotSendNotReceiveInAtomic(Atomic s) {
		if(s.deterministic){
		val list = s.corps.steps
			list.forEach[
				if (it instanceof Send || it instanceof Receive) {
					error("Deterministic cannot contain Send or Receive statement", PromelaPackage.Literals.ATOMIC__CORPS)
				}]
		}

	}

@Check
	def checkAtomicContainsOnlyInstruction(Atomic a) {
		a.corps.steps.forEach [
			if (! (it instanceof Instruction))
				error("Atomic must contain only Instruction", PromelaPackage.Literals.ATOMIC__CORPS)
		]

	}

@Check
	def checkNoEmptySequence(Sequence s) {
		if (s.steps.empty)
			warning('''The sequence may not be empty''', s.eContainer, null, PROMELA_STEP_SKIP)
	}

@Check
	def checkAssignmentVar(Assignment a) {
		if (!( a.^var instanceof Reference))
			error("Assignement can only be done to variable Ref, not to " + a.^var.eClass.name, PromelaPackage.Literals.ASSIGNMENT__VAR)
//		if ( a.^var instanceof Reference ){
//			if ( a.^var instanceof AtomicRef 
//				&& (a.^var as AtomicRef).ref instanceof MemVariable
//				&& ((a.^var as AtomicRef).ref as MemVariable).array ) {
//				error("Assignment to array cell missing index expression, add "+ ((a.^var as AtomicRef).ref as MemVariable).name + " [XXX]", PromelaPackage.Literals.ASSIGNMENT__VAR)					
//			}
//			if ( a.^var instanceof TabRef 
//				&& (a.^var as TabRef).ref instanceof MemVariable
//				&& ! ((a.^var as TabRef).ref as MemVariable).array ) {
//				error("Assignment to non array variable "+ ((a.^var as AtomicRef).ref as MemVariable).name + " with index expression [XXX] is illegal.", PromelaPackage.Literals.ASSIGNMENT__VAR)					
//			}			
//		}
	}

	@Check
	def checkTabRef (TabRef tref) {
		if ( tref.ref instanceof AtomicRef 
			&& (tref.ref as AtomicRef).ref  instanceof MemVariable 
			&& ! ((tref.ref as AtomicRef).ref as MemVariable).array
		) {
			error("Access a plain (non array) variable using index expression is illegal.", PromelaPackage.Literals.TAB_REF__INDEX)								
		}
	}
	
	@Check
	def checkAtomicRef (AtomicRef aref) {
		if (aref.ref  instanceof MemVariable && (aref.ref as MemVariable).array && (! (aref.eContainer instanceof TabRef)) ) {
			error("Access to array cell missing index expression, add "+ (aref.ref as MemVariable).name + " [XXX]", PromelaPackage.Literals.ATOMIC_REF__REF)								
		}
	}

@Check
	def checkAssignmentVarAssigned(Assignment a) {
		if (a.kind == AssignmentOperators.STD && a.newValue == null)
			error("Standard Assignement need a new value " + a.^var, PromelaPackage.Literals.ASSIGNMENT__NEW_VALUE)
	}

@Check
	def checkSendChannel(Send a) {
		if (!( a.channel instanceof AtomicRef))
			error("Send can only be done to channel " + a.channel, PromelaPackage.Literals.SEND__CHANNEL)
	}

@Check
	def checkReceiveChannel(Receive a) {
		if (!( a.channel instanceof AtomicRef))
			error("Receive can only be done to channel " + a.channel, PromelaPackage.Literals.RECEIVE__CHANNEL)
	}

@Check
	def checkPollChannel(Poll a) {
		if (!( a.channel instanceof AtomicRef))
			error("Send can only be done to channel " + a.channel, PromelaPackage.Literals.POLL__CHANNEL)
	}

}
