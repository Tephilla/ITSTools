/*
 * generated by Xtext
 */
package fr.lip6.move.promela.formatting

import fr.lip6.move.promela.services.PromelaGrammarAccess
import fr.lip6.move.promela.services.PromelaGrammarAccess.AtomicElements
import fr.lip6.move.promela.services.PromelaGrammarAccess.ChanInitializeElements
import fr.lip6.move.promela.services.PromelaGrammarAccess.ForElements
import fr.lip6.move.promela.services.PromelaGrammarAccess.InitProcessElements
import fr.lip6.move.promela.services.PromelaGrammarAccess.IterationElements
import fr.lip6.move.promela.services.PromelaGrammarAccess.NamedProcessElements
import fr.lip6.move.promela.services.PromelaGrammarAccess.SelectionElements
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.formatting.impl.AbstractDeclarativeFormatter
import org.eclipse.xtext.formatting.impl.FormattingConfig

// import com.google.inject.Inject;
// import fr.lip6.move.promela.services.PromelaGrammarAccess

/** 
 * This class contains custom formatting description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#formatting
 * on how and when to use it 
 * 
 * Also see {@link org.eclipse.xtext.xtext.XtextFormattingTokenSerializer} as an example
 */
class PromelaFormatter extends AbstractDeclarativeFormatter {

//	@Inject extension PromelaGrammarAccess
	
		// @Inject extension PromelaGrammarAccess

	override protected void configureFormatting(FormattingConfig c) {

		var PromelaGrammarAccess pga = getGrammarAccess() as PromelaGrammarAccess
		c.setAutoLinewrap(250) // 250 caractères par ligne maximum
		configure(c, pga)
	}

	def protected void configure(FormattingConfig c, PromelaGrammarAccess pga) {

		configureKeyWords(c, pga);
		configureNamedProcess(c, pga.namedProcessAccess)
		configuredInitProcess(c, pga.initProcessAccess)
		configureSelection(c, pga.selectionAccess)
		configureIteration(c, pga.iterationAccess)
		configureFor(c, pga.forAccess)
		configureChanInit(c, pga.chanInitializeAccess)
		configureAtomic(c, pga.atomicAccess)
			
		// format define
		c.setLinewrap().after(pga.defineIntMacroRule)
		c.setNoSpace().before(pga.defineIntMacroRule)

		// comments
		c.setLinewrap(0, 1, 2).before(pga.getSL_COMMENTRule())
		c.setLinewrap(0, 1, 2).before(pga.getML_COMMENTRule())
		c.setLinewrap(0, 1, 1).after(pga.getML_COMMENTRule())

	}

	def protected void configureKeyWords(FormattingConfig c, PromelaGrammarAccess pga) {
		// delete spaces before , and ;
		for (Keyword comma : pga.findKeywords(",")) {
			c.setNoSpace().before(comma)
			c.setSpace(" ").after(comma)
		}

		for (Keyword equal : pga.findKeywords("=")) {
			c.setSpace(" ").before(equal)
			c.setSpace(" ").after(equal)
		}

		for (Keyword semicolon : pga.findKeywords(";")) {
			c.setNoSpace().before(semicolon)
			c.setLinewrap().after(semicolon)
		}

		// ici pb si on a une flèche je ne veux pas retourner à la ligne
		// si je rajoute les deux lignes suivantes, par contre, pb car pas de retour à la ligne après tous les ;
		// c.setNoLinewrap().after(pga.getSEPAccess().getHyphenMinusGreaterThanSignKeyword_0_0());
		// c.setLinewrap().after(pga.getSEPAccess().getSemicolonKeyword_0_1());
		c.setNoSpace().before(pga.SEPRule)
		c.setLinewrap().after(pga.SEPRule)

		// Je laisse cet exemple pour les pairs car il peut être utile plus tard, sait-on jamais
		// for (Pair<Keyword,Keyword> pair : pga.findKeywordPairs("{","}")) {
		//
		// c.setSpace("\n").after(pair.getFirst());
		// c.setSpace("\n").before(pair.getSecond());
		// }
	}

	def public void configureNamedProcess(FormattingConfig c,
			NamedProcessElements nel) {
		// format NamedProcess
		c.setLinewrap(2).before(nel.rule)
		c.setSpace(" ").before(nel.leftCurlyBracketKeyword_8)
		c.setLinewrap().after(nel.leftCurlyBracketKeyword_8)
		c.setLinewrap().after(nel.rightCurlyBracketKeyword_10)
		c.setLinewrap().before(nel.rightCurlyBracketKeyword_10)
		c.setIndentation(nel.leftCurlyBracketKeyword_8,
				nel.rightCurlyBracketKeyword_10)

	}

	def protected void configuredInitProcess(FormattingConfig c, InitProcessElements ip) {
		c.setLinewrap(2).before(ip.rule)
		c.setSpace(" ").before(ip.leftCurlyBracketKeyword_2)
		c.setLinewrap().after(ip.leftCurlyBracketKeyword_2)
		c.setLinewrap().after(ip.rightCurlyBracketKeyword_4)
		c.setLinewrap().before(ip.rightCurlyBracketKeyword_4)
		c.setIndentation(ip.leftCurlyBracketKeyword_2,
				ip.rightCurlyBracketKeyword_4)
	}

	def protected void configureSelection(FormattingConfig c, SelectionElements sel) {
		c.setLinewrap().after(sel.ifKeyword_0)
		c.setLinewrap().after(sel.fiKeyword_4)
		c.setLinewrap().before(sel.fiKeyword_4)
		c.setIndentation(sel.ifKeyword_0, sel.fiKeyword_4)
		c.setLinewrap().before(sel.colonColonKeyword_2_0)
		c.setLinewrap().before(sel.colonColonKeyword_3_0)
	}

	def protected void configureIteration(FormattingConfig c, IterationElements ie) {
		c.setLinewrap().after(ie.doKeyword_0)
		c.setLinewrap().after(ie.odKeyword_4)
		c.setLinewrap().before(ie.odKeyword_4)
		c.setIndentation(ie.doKeyword_0, ie.odKeyword_4)
		c.setLinewrap().before(ie.colonColonKeyword_2_0)
		c.setLinewrap().before(ie.colonColonKeyword_3_0)
	}

	def protected void configureFor(FormattingConfig c, ForElements fe) {
		c.setNoSpace().after(fe.leftParenthesisKeyword_1)
		c.setNoSpace().before(fe.rightParenthesisKeyword_4)
		c.setLinewrap().after(fe.leftCurlyBracketKeyword_5)
		c.setLinewrap().before(fe.rightCurlyBracketKeyword_7)
		c.setIndentation(fe.leftCurlyBracketKeyword_5,
				fe.rightCurlyBracketKeyword_7)
	}

	def protected void configureChanInit(FormattingConfig c, ChanInitializeElements cie) {
		c.setSpace(" ").after(cie.leftSquareBracketKeyword_0)
		c.setSpace(" ").before(cie.rightSquareBracketKeyword_2)
		c.setSpace(" ").after(cie.leftCurlyBracketKeyword_4)
		c.setSpace(" ").before(cie.rightCurlyBracketKeyword_7)
	}
	
	def protected void configureAtomic(FormattingConfig c, AtomicElements ae){
		c.setLinewrap().after(ae.rightCurlyBracketKeyword_4)
		c.setLinewrap().after(ae.leftCurlyBracketKeyword_2)
	}
// It's usually a good idea to activate the following three statements.
// They will add and preserve newlines around comments
//		c.setLinewrap(0, 1, 2).before(SL_COMMENTRule)
//		c.setLinewrap(0, 1, 2).before(ML_COMMENTRule)
//		c.setLinewrap(0, 1, 1).after(ML_COMMENTRule)
	
}
