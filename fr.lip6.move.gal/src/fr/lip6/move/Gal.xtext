grammar fr.lip6.move.Gal with org.eclipse.xtext.xbase.Xbase

generate gal "http://www.lip6.fr/move/Gal"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://coloane.lip6.fr/model/1.0" as model



Specification :
	(imports+=Import)*
	(interfaces+=Interface
	| types+=TypeDeclaration
	| typedefs+=TypedefDeclaration
	| params += ConstParameter ';'
	)*
	(
		'main' main=[TypeDeclaration|FullyQualifiedName] ';'
	)?
;

Import:
	'import' importURI=STRING ';'
;

Interface :
	'interface' name=ID '{'
		( labels+=Label ';' )*	
	'}'
;

TypeDeclaration :
	GALTypeDeclaration
	| CompositeTypeDeclaration
;




/**
 * System
 */
GALTypeDeclaration:
	('gal'|'GAL') name=FullyQualifiedName 
	('('
	params += ConstParameter
	( ',' params+= ConstParameter)* 
	')')?
	'{'
	(
	(types+=TypedefDeclaration)
	|(variables+=VariableDeclaration) 
	|(arrays+=ArrayDeclaration) 
//	|(lists+=ListDeclaration)
	)*
	(transitions+=Transition)*
	(transient=Transient)?
	'}';

CompositeTypeDeclaration :
	'composite' name=ID 
	( '<' templateParams+=TemplateParam   ( ',' templateParams +=TemplateParam )*   '>' )?
	('('
	params += ConstParameter
	( ',' params+= ConstParameter)* 
	')')?
	'{'
		(instances+=AbstractInstance)*
		(synchronizations+=Synchronization)*
	'}'
;

TypedefDeclaration: (comment=COMMENT)? 'typedef' name=ID '=' min=BitOr '..' max=BitOr ';';

TemplateParam :
	name=ID 'extends' interfaces+=[Interface] ( ',' interfaces+=[Interface] )* 
;


Transient:
	'TRANSIENT' '=' value=Or ';';

/* ============ GAL System Content ================== */

VarDecl :
	VariableDeclaration | ArrayDeclaration
;

//Ex: int abc = 10 ; 
VariableDeclaration returns Variable:
	(comment=COMMENT)?
	(hotbit?='hotbit' '(' hottype=[TypedefDeclaration] ')')? 'int' name=FullyQualifiedName '=' value=BitOr ';';


	//Ex: array[1] tab = (2) ;
ArrayDeclaration returns ArrayPrefix:
	(comment=COMMENT)?
	(hotbit?='hotbit' '(' hottype=[TypedefDeclaration] ')')? 
	'array' '[' size=INT ']' name=FullyQualifiedName '=' '(' ( (values+=BitOr) (',' values+=BitOr)* )? ')' ';';

//ListDeclaration returns List:
//	'list' name=FullyQualifiedName ('=' '(' ( (values+=BitOr) (',' values+=BitOr)* )? ')')? ';';

Transition:
	(comment=COMMENT)? 
	'transition' name=FullyQualifiedName 
	('(' params+=Parameter 	( ',' params+=Parameter)* ')')? 
	'[' guard=Or ']' 
	('label' label=Label)? 
	'{'
	(actions+=Actions)*
	'}';


AbstractParameter :
	Parameter | ConstParameter | ForParameter
;

Parameter :
	type=[TypedefDeclaration] name=PARAMNAME
;

ConstParameter : 
	name=PARAMNAME '=' value=Integer
;


/*  ========= Transition Content ============ */
Actions:
	Assignment  | Ite | Call | Abort | Fixpoint | For 
//	| Push | Pop
	;

//Push:
//	'push' '(' list=[List|FullyQualifiedName] ',' value=BitOr ')' ';';
//
//Pop:
//	'pop' '(' list=[List|FullyQualifiedName] ')' ';';

Assignment:
	(comment=COMMENT)? 	
	left=VarAccess '=' right=BitOr ';';

Ite:(comment=COMMENT)? 	
	'if' '(' cond=Or ')' '{' (ifTrue+=Actions)* '}'
	('else'  '{' (ifFalse+=Actions)*  '}')?	
;

Fixpoint:
	{Fixpoint}
	(comment=COMMENT)? 	
	'fixpoint' '{' (actions+=Actions)* '}'
;


Call:
	(comment=COMMENT)? 	
	'self' '.' label=[Label|STRING] ';';

Abort:
	{Abort} 
	(comment=COMMENT)? 	
	'abort' ';'
;

For : 
	(comment=COMMENT)? 		
	'for' '(' param=ForParameter ')' 
	'{'
		(actions+=Actions)*
	'}' 
;

ForParameter returns Parameter: 
	name=PARAMNAME ':' type=[TypedefDeclaration] 
;

VarAccess:
	ArrayVarAccess | VariableRef ;

VariableRef:
	referencedVar=[Variable|FullyQualifiedName];

ArrayVarAccess:
	prefix=[ArrayPrefix|FullyQualifiedName] '[' index=BitOr ']';

ParamRef:
	refParam=[AbstractParameter|PARAMNAME]
;



/* =====   Arithmetic expressions ===== */

/* ====== Bitwise operators ======= */
BitOr returns IntExpression:
	BitXor ({BinaryIntExpression.left=current} op='|' right=BitXor)*;

BitXor returns IntExpression:
	BitAnd ({BinaryIntExpression.left=current} op='^' right=BitAnd)*;

BitAnd returns IntExpression:
	BitShift ({BinaryIntExpression.left=current} op='&' right=BitShift)*;

BitShift returns IntExpression:
	Addition ({BinaryIntExpression.left=current} op=('<<' | '>>') right=Addition)*;

Addition returns IntExpression:
	Multiplication ({BinaryIntExpression.left=current} op=('+' | '-') right=Multiplication)*;

Multiplication returns IntExpression:
	UnaryExpr ({BinaryIntExpression.left=current} op=('/' | '*' | '%') right=UnaryExpr)*;

UnaryExpr returns IntExpression :
	BitComplement | UnaryMinus | Power
;

UnaryMinus returns IntExpression:
    {UnaryMinus} '-' value=UnaryExpr;
    
BitComplement returns IntExpression:
	{BitComplement} '~' value=UnaryExpr ;

Power returns IntExpression:
	Primary ({BinaryIntExpression.left=current} op=('**') right=Primary)*;

Primary returns IntExpression:
//	Peek |
	VarAccess |
	ConstRef |
	(=> ('(' BitOr ')') | ('(' WrapBoolExpr ')'));

ConstRef returns IntExpression:
	Constant |
	ParamRef ;
	

WrapBoolExpr:
	value=Or;

Constant:
	value=INT;

//Peek:
//	'peek' '(' list=[List|FullyQualifiedName] ')';

/* =====   Boolean expressions ===== */
enum ComparisonOperators:
	GT='>' | // Greater Thean
	LT='<' | // Lower Than
	GE='>=' | // Greater or Equal
	LE='<=' | // Lower or Equal
	EQ='==' | // Equal
	NE='!='; // Not Equal
	
Or returns BooleanExpression:
	(And ({Or.left=current} '||' right=And)*);

And returns BooleanExpression:
	Not ({And.left=current} '&&' right=Not)*;

Not returns BooleanExpression:
	('!' {Not} value=PrimaryBool) | PrimaryBool;

PrimaryBool returns BooleanExpression:
	True | False | => Comparison | ('(' Or ')');

Comparison:
	(left=BitOr
	operator=ComparisonOperators
	right=BitOr);

True:
	{True}
	'true';

False:
	{False}
	'false';

GalInstance:
	'gal' type = [GALTypeDeclaration] name = ID 
	( '(' paramDefs+=GALParamDef  (',' paramDefs+=GALParamDef )* ')' )? 
	';'
;

GALParamDef :
	param=[ConstParameter|PARAMNAME] '=' value=Integer 
;

ItsInstance:
	'composite'  type = [CompositeTypeDeclaration] name = ID ';'
;

OtherInstance:
	'gmodel' type = [model::Tmodel] name = ID ';'
;

TemplateInstance:
	'template' type = [TemplateParam] name = ID ';'
;


AbstractInstance:
   ItsInstance | GalInstance  | TemplateInstance
    | OtherInstance
;

Synchronization:
	'synchronization' name = ID 'label' label = Label '{'
		(actions+=Action)*
	'}'
;

Action:
	InstanceCall | SelfCall
;


/* =====   Basic types ===== */

InstanceCall:
    instance=[AbstractInstance]'.'label=[ecore::EObject|STRING] ';'
;

SelfCall:
	'self''.' label = [ecore::EObject|STRING] ';'
;

/* =====   Basic types ===== */


Label :
	name=STRING
;

// Our qualified name may have integer at any position except first one
FullyQualifiedName:
	ID ( '.' (ID|INT))*
;

terminal COMMENT :
	'/**' -> '*/' 
;
terminal ML_COMMENT : 
	'xxxXXXxxx'
;

terminal PARAMNAME:
	'$'  ('^')?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

Integer returns ecore::EInt:
	('-')? INT;
