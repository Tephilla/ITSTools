grammar fr.lip6.move.Gal with org.eclipse.xtext.common.Terminals

generate gal "http://www.lip6.fr/move/Gal"

/* -----------------------------------------------------------*
 * Grammaire GAL
 * ---
 * 
 * -----------------------------------------------------------*/

System:
	'GAL' name=QualifiedName '{'
	(
		(variables+=VariableDeclaration)* &
		(arrays+=ArrayDeclaration)*       &
		(lists+=ListDeclaration)*         &
		(transitions+=Transition)*        & 
		(transient=Transient)?
	)
	'}';


Transient:
	'TRANSIENT' '=' value=Or ';'
;


/* ============ System Content ================== */

//Ex: int abc = 10 ; 
VariableDeclaration returns Variable:
    'int' name=QualifiedName '=' value=INT ';';

    //Ex: array[1] tab = (2) ;
ArrayDeclaration returns ArrayPrefix:
    'array' '[' size=INT ']' name=QualifiedName '=' '(' (values=InitValues)? ')' ';';

ListDeclaration returns List:
    'list' name=QualifiedName ('=' '(' (values=InitValues)? ')')? ';';

InitValues:
    (values+=INT) (',' values+=INT)*;

Transition:
    'transition' name=QualifiedName '[' guard=Or ']' ('label' label=QualifiedName)? '{'
    (actions+=Actions)*
    '}';

/*  ========= Transition Content ============ */
Actions:
    Assignment | Push | Pop;

Push:
    liste=[List|QualifiedName] '.push' '(' value=BitOr ')' ';';

Pop:
    liste=[List|QualifiedName] '.pop' '(' ')' ';';

Peek:
    (isNegative?='-')? liste=[List|QualifiedName] '.peek' '(' ')';

Assignment:
    left=VarAccess '=' right=BitOr ';';

VarAccess:
    ArrayVarAccess | VariableRef;

VariableRef:
    (isNegative?='-')? var=[Variable|QualifiedName];

ArrayVarAccess:
    (isNegative?='-')? prefix=[ArrayPrefix|QualifiedName] '[' index=BitOr ']';

/* =====   Arithmetic expressions ===== */
enum BinaryArithLowPriorityOperator:
    PLUS='+' | MINUS='-';

enum BinaryArithMiddlePriorityOperator:
    DIVISION='/' |
    MULT='*' |
    MODULO='%';

enum BinaryArithHighPriorityOperator:
    POWER='**';

enum BinaryArithLowLowPriorityOperator:
    LEFT_SHIFT="<<" |
    RIGHT_SHIFT=">>";

/* ====== Opérateurs Bit à bit ======= */
//Opérateurs, du plus prioritaire au moins prioritaire
//()
//~ (-)
//* / %
//+ -
//<< >> DECALAGE
//& AND
//^ XOR
//| OR

BitOr returns IntExpression:
    BitXor ({BitOr.left=current} '|' right=BitXor)*;

BitXor returns IntExpression:
    BitAnd ({BitXor.left=current} '^' right=BitAnd)*;

BitAnd returns IntExpression:
    BitShift ({BitAnd.left=current} '&' right=BitShift)*;

BitShift returns IntExpression:
    Addition ({BitShift.left=current} op=BinaryArithLowLowPriorityOperator right=Addition)*;

Addition returns IntExpression:
    Multiplication ({Addition.left=current} op=BinaryArithLowPriorityOperator right=Multiplication)*;

Multiplication returns IntExpression:
    BitComplement ({Multiplication.left=current} op=BinaryArithMiddlePriorityOperator right=BitComplement)*
;

BitComplement returns IntExpression:
    '~'? Power ({BitComplement.val=current});

Power returns IntExpression:
    /*'-'?*/ Primary ({Power.left=current} op=BinaryArithHighPriorityOperator right=Primary)*;

Primary returns IntExpression:
    Peek               |
    VarAccess          |
    Constante          |
    (=>('(' BitOr ')') | 
    ('(' WrapBoolExpr')'));

WrapBoolExpr:
    val=Or;

Constante:
  (isNegative?='-')? val=INT;

/* =====   Boolean expressions ===== */
enum ComparisonOperators:
    GT='>' |  // Greater Thean
    LT='<' |  // Lower Than
    GE='>=' | // Greater or Equal
    LE='<=' | // Lower or Equal
    EQ='==' | // Equal
    NE='!=';  // Not Equal

Or returns BooleanExpression:
    (And ({Or.left=current} '||' right=And)*);

And returns BooleanExpression:
    Not ({And.left=current} '&&' right=Not)*;

Not returns BooleanExpression:
    ('!'? (PrimaryBool) {Not.val=current});

PrimaryBool returns BooleanExpression:
    True | False | => Comparison | ('(' Or ')');

Comparison:
    (left=BitOr
    operator=ComparisonOperators
    right=BitOr);

True:
    val='True';

False:
    val='False';

QualifiedName:
    ID ('.' (INT | ID))*;

