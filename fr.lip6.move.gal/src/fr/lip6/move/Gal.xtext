grammar fr.lip6.move.Gal with org.eclipse.xtext.xbase.Xbase

generate gal "http://www.lip6.fr/move/Gal"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore


/**
 * System
 */
System:
	'GAL' name=QualifiedName '{'
	(
	(variables+=VariableDeclaration) 
	|(arrays+=ArrayDeclaration) 
	// Cause trouble between list's operations and qualified name 
	//|(lists+=ListDeclaration)
	)*
	transitions+=Transition+
	(transient=Transient)?
	'}';

Transient:
	'TRANSIENT' '=' value=Or ';';

/* ============ System Content ================== */

//Ex: int abc = 10 ; 
VariableDeclaration returns Variable:
	'int' name=QualifiedName '=' value=Integer ';';

	//Ex: array[1] tab = (2) ;
ArrayDeclaration returns ArrayPrefix:
	'array' '[' size=INT ']' name=QualifiedName '=' '(' (values=InitValues)? ')' ';';

ListDeclaration returns List:
	'list' name=QualifiedName ('=' '(' (values=InitValues)? ')')? ';';

InitValues:
	(values+=Integer) (',' values+=Integer)*;

Transition:
	'transition' name=QualifiedName '[' guard=Or ']' ('label' label=STRING)? '{'
	(actions+=Actions)*
	'}';

/*  ========= Transition Content ============ */
Actions:
	Assignment | Push | Pop;

Push:
	list=[List|QualifiedName] '.push' '(' value=BitOr ')' ';';

Pop:
	list=[List|QualifiedName] '.pop' '(' ')' ';';

Assignment:
	left=VarAccess '=' right=BitOr ';';

VarAccess:
	ArrayVarAccess | VariableRef;

VariableRef:
	referencedVar=[Variable|QualifiedName];

ArrayVarAccess:
	prefix=[ArrayPrefix|QualifiedName] '[' index=BitOr ']';

/* =====   Arithmetic expressions ===== */

/* ====== Opérateurs Bit à bit ======= */
BitOr returns IntExpression:
	BitXor ({BinaryIntExpression.left=current} op='|' right=BitXor)*;

BitXor returns IntExpression:
	BitAnd ({BinaryIntExpression.left=current} op='^' right=BitAnd)*;

BitAnd returns IntExpression:
	BitShift ({BinaryIntExpression.left=current} op='&' right=BitShift)*;

BitShift returns IntExpression:
	Addition ({BinaryIntExpression.left=current} op=('<<' | '>>') right=Addition)*;

Addition returns IntExpression:
	Multiplication ({BinaryIntExpression.left=current} op=('+' | '-') right=Multiplication)*;

Multiplication returns IntExpression:
	BitComplement ({BinaryIntExpression.left=current} op=('/' | '*' | '%') right=BitComplement)*;

BitComplement returns IntExpression:
	('~' Power ({BitComplement.value=current})) |
	('-' Power ({UnaryMinus.value=current})) |
	(Power);

Power returns IntExpression:
	Primary ({BinaryIntExpression.left=current} op=('**') right=Primary)*;

Primary returns IntExpression:
	Peek |
	VarAccess |
	Constant |
	(=> ('(' BitOr ')') | ('(' WrapBoolExpr ')'));

WrapBoolExpr:
	value=Or;

Constant:
	value=INT;

Peek:
	list=[List|QualifiedName] '.peek' '(' ')';

/* =====   Boolean expressions ===== */
enum ComparisonOperators:
	GT='>' | // Greater Thean
	LT='<' | // Lower Than
	GE='>=' | // Greater or Equal
	LE='<=' | // Lower or Equal
	EQ='==' | // Equal
	NE='!='; // Not Equal
	
Or returns BooleanExpression:
	(And ({Or.left=current} '||' right=And)*);

And returns BooleanExpression:
	Not ({And.left=current} '&&' right=Not)*;

Not returns BooleanExpression:
	('!' PrimaryBool {Not.value=current}) | PrimaryBool;

PrimaryBool returns BooleanExpression:
	True | False | => Comparison | ('(' Or ')');

Comparison:
	(left=BitOr
	operator=ComparisonOperators
	right=BitOr);

True:
	value='True';

False:
	value='False';

/* =====   Basic types ===== */

// Dots are permitted after the first character
// WARNING : Now QualifiedName may looks like: "a...b"
terminal ID :
	('^'? ('a'..'z'|'A'..'Z'|'$'|'_') ('a'..'z'|'A'..'Z'|'$'|'_'|'.'|'0'..'9')*)
	;

Integer returns ecore::EInt:
	('-')? INT;
