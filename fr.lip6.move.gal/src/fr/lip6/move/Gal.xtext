grammar fr.lip6.move.Gal with org.eclipse.xtext.common.Terminals

generate gal "http://www.lip6.fr/move/Gal"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

/**
 * System
 */
System:
	'GAL' name=QualifiedName '{'
	((variables+=VariableDeclaration)* &
	(arrays+=ArrayDeclaration)* &
	(lists+=ListDeclaration)* &
	(transitions+=Transition)* &
	(transient=Transient)?)
	'}';

Transient:
	'TRANSIENT' '=' value=Or ';';

/* ============ System Content ================== */

//Ex: int abc = 10 ; 
VariableDeclaration returns Variable:
	'int' name=QualifiedName '=' value=Integer ';';

	//Ex: array[1] tab = (2) ;
ArrayDeclaration returns ArrayPrefix:
	'array' '[' size=INT ']' name=QualifiedName '=' '(' (values=InitValues)? ')' ';';

ListDeclaration returns List:
	'list' name=QualifiedName ('=' '(' (values=InitValues)? ')')? ';';

InitValues:
	(values+=Integer) (',' values+=Integer)*;

Transition:
	'transition' name=QualifiedName '[' guard=Or ']' ('label' label=QualifiedName)? '{'
	(actions+=Actions)*
	'}';

/*  ========= Transition Content ============ */
Actions:
	Assignment | Push | Pop;

Push:
	list=[List|QualifiedName] '.push' '(' value=BitOr ')' ';';

Pop:
	list=[List|QualifiedName] '.pop' '(' ')' ';';

Peek:
	list=[List|QualifiedName] '.peek' '(' ')';

Assignment:
	left=VarAccess '=' right=BitOr ';';

VarAccess:
	ArrayVarAccess | VariableRef;

VariableRef:
	referencedVar=[Variable|QualifiedName];

ArrayVarAccess:
	prefix=[ArrayPrefix|QualifiedName] '[' index=BitOr ']';

/* =====   Arithmetic expressions ===== */

/* ====== Opérateurs Bit à bit ======= */
BitOr returns IntExpression:
	BitXor ({BinaryIntExpression.left=current} op='|' right=BitXor)*;

BitXor returns IntExpression:
	BitAnd ({BinaryIntExpression.left=current} op='^' right=BitAnd)*;

BitAnd returns IntExpression:
	BitShift ({BinaryIntExpression.left=current} op='&' right=BitShift)*;

BitShift returns IntExpression:
	Addition ({BinaryIntExpression.left=current} op=('<<' | '>>') right=Addition)*;

Addition returns IntExpression:
	Multiplication ({BinaryIntExpression.left=current} op=('+' | '-') right=Multiplication)*;

Multiplication returns IntExpression:
	BitComplement ({BinaryIntExpression.left=current} op=('/' | '*' | '%') right=BitComplement)*;

BitComplement returns IntExpression:
	('~' Power ({BitComplement.value=current})) | (Power);

Power returns IntExpression:
	Primary ({BinaryIntExpression.left=current} op=('**') right=Primary)*;

Primary returns IntExpression:
	'-'? Peek |
	'-'? VarAccess |
	Constant |
	'-'? (=> ('(' BitOr ')') | ('(' WrapBoolExpr ')'));

WrapBoolExpr:
	value=Or;

Constant:
	value=Integer;

/* =====   Boolean expressions ===== */
enum ComparisonOperators:
	GT='>' | // Greater Thean
	LT='<' | // Lower Than
	GE='>=' | // Greater or Equal
	LE='<=' | // Lower or Equal
	EQ='==' | // Equal
	NE='!='; // Not Equal
Or returns BooleanExpression:
	(And ({Or.left=current} '||' right=And)*);

And returns BooleanExpression:
	Not ({And.left=current} '&&' right=Not)*;

Not returns BooleanExpression:
	('!' (PrimaryBool) {Not.value=current}) | PrimaryBool;

PrimaryBool returns BooleanExpression:
	True | False | => Comparison | ('(' Or ')');

Comparison:
	(left=BitOr
	operator=ComparisonOperators
	right=BitOr);

True:
	value='True';

False:
	value='False';

/* =====   Basic types ===== */
QualifiedName:
	ID ('.' (INT | ID))*;

Integer returns ecore::EInt:
	('-')? INT;

