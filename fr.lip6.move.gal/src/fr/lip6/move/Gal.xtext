grammar fr.lip6.move.Gal with org.eclipse.xtext.common.Terminals

generate gal "http://www.lip6.fr/move/Gal"

//grammar fr.lip6.move.GAL with org.eclipse.xtext.common.Terminals
//
//generate gAL "http://www.lip6.fr/move/GAL"

// grammar fr.lip6.move.Gal with org.eclipse.xtext.common.Terminals
//
//generate gal "http://www.lip6.fr/move/Gal"

System :
    ('GAL' name=QualifiedName '{'
        (variables+=VariableDeclaration)*
        transitions+=Transition+
       '}'
    )?
;

VariableDeclaration returns Variable:
    name=QualifiedName '=' initVal=INT ';'
;

//VariableArrayDeclaration:
//	arrayName=QualifiedName'[' index=UnaryIntExpression']' '=' initVal=INT
//;



/*
 * Parenthèses obligatoires autour de la garde!
 */
 
Transition:
    'transition' name=ID '[' guard=Or ']' ('label' label=ID)? '{'
        (assignments+=Assignment )+
    '}'  
;



Assignment :
    var=VariableRef '=' expr=(UnaryIntExpression)
;



/* =====   Arithmetic expressions ===== */


enum BinaryArithmeticOperations:
	PLUS 	 = '+' 	| 
	MINUS 	 = '-'	| 
	DIVISION = '/' 	| 
	MULT 	 = '*'	|
	MODULO 	 = '%'	|
	POWER 	 = '**'
;


/*
 * Ces expressions entières ne peuvent pas parser ce genre d'expressions
 * 1 * (-a) 
 */


BinaryIntExpression returns IntExpression:
	UnaryIntExpression ({BinaryIntExpression.left=current}
	op=BinaryArithmeticOperations
	right=UnaryIntExpression)*
;


UnaryIntExpression returns IntExpression:
	'-'?
	Primary ({UnaryIntExpression.val=current})
;


Primary returns IntExpression :
    VariableRef | Constante | '(' BinaryIntExpression ')'
;


Constante:
    val=INT
;

VariableRef:
    var=[Variable]
;




/* =====   Boolean expressions ===== */


enum ComparisonOperators:
	GT	=	'>'		|
	LT	=	'<'		|
	GQ	=	'>='	|
	LQ	=	'<='	|
	EQ	=	'=='	|
	NQ	=	'!='
;


Or returns BooleanExpression :
    Comparison | (And ({Or.left=current} '||' right=And)*)
;


And returns BooleanExpression:
    Not ({And.left=current} '&&' right=Not)*
;


Not returns BooleanExpression :
    ('!' ? (PrimaryBool) {Not.val=current})
;


PrimaryBool returns BooleanExpression:
    True | False |  ('(' Or ')' ) /*| Comparison*/
;


Comparison:
	(left=BinaryIntExpression
	operator=ComparisonOperators
	right=BinaryIntExpression)
;



True:
	val='True'
;

False:
	val='False'
;





















//les imports

QualifiedName:
	ID('.' ID)*
;

QualifiedNameWithWildCard:
	QualifiedName '.*'?
;

Import:
	'import' QualifiedNameWithWildCard
;