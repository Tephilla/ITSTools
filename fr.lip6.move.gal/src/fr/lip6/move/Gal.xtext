grammar fr.lip6.move.Gal with org.eclipse.xtext.xbase.Xbase

generate gal "http://www.lip6.fr/move/Gal"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore


Specification :
	imports+=Import*
	(interfaces+=Interface
	| types+=GALOrCompositeTypeDeclaration
	| typedefs+=TypedefDeclaration
	| params += ConstParameter ';'
	)*
	(
		'main' main=[TypeDeclaration|FullyQualifiedName] ';'
	)?
	(properties+=Property) *
;

Import:
	'import' importURI=STRING ';'
;

Interface :
	'interface' name=ID '{'
		( labels+=Label ';' )*	
	'}'
;

//these are the real types
GALOrCompositeTypeDeclaration returns TypeDeclaration :
	GALTypeDeclaration
	| CompositeTypeDeclaration	
;

//this enforces that a TemplateTypeDeclaration is a legal target for InstanceDecl
TypeDeclaration :
	GALTypeDeclaration
	| CompositeTypeDeclaration
	| TemplateTypeDeclaration
;





/**
 * System
 */
GALTypeDeclaration:
	('gal'|'GAL') name=FullyQualifiedName 
	('('
	params += ConstParameter
	( ',' params+= ConstParameter)* 
	')')?
	'{'
	(
	(typedefs+=TypedefDeclaration)
	|(variables+=VariableDeclaration) 
	|(arrays+=ArrayDeclaration) 
//	|(lists+=ListDeclaration)
	)*
	(transitions+=Transition 
	| predicates+=Predicate	
	)*
	('TRANSIENT' '=' transient=Or ';')?
	'}';

CompositeTypeDeclaration :
	'composite' name=ID 
	( '<' templateParams+=TemplateTypeDeclaration   ( ',' templateParams +=TemplateTypeDeclaration )*   '>' )?
	('('
	params += ConstParameter
	( ',' params+= ConstParameter)* 
	')')?
	'{'
		(typedefs+=TypedefDeclaration |
		instances+=InstanceDecl)*
		(synchronizations+=Synchronization)*
	'}'
;

// A typedef found in many places (spec, gal, composite)
TypedefDeclaration: (comment=COMMENT)? 'typedef' name=ID '=' min=BitOr '..' max=BitOr ';';

TemplateTypeDeclaration  :
	name=ID 'extends' interfaces+=[Interface] ( ',' interfaces+=[Interface] )* 
;




/* ============ GAL System Content ================== */

NamedDeclaration : VarDecl | InstanceDecl ;

VarDecl :
	VariableDeclaration | ArrayDeclaration
;

InstanceDecl :
	InstanceDeclaration | ArrayInstanceDeclaration
;

//Ex: int abc = 10 ; 
VariableDeclaration returns Variable:
	(comment=COMMENT)?
	(hotbit?='hotbit' '(' hottype=[TypedefDeclaration] ')')? 
	'int' name=FullyQualifiedName 
	('=' value=BitOr)? /* initial value is now optional, default is 0 */
	 ';'
;


	//Ex: array[1] tab = (2) ;
ArrayDeclaration returns ArrayPrefix:
	(comment=COMMENT)?
	(hotbit?='hotbit' '(' hottype=[TypedefDeclaration] ')')? 
	'array' '[' size=BitOr ']' name=FullyQualifiedName 
	('=' '(' ( (values+=BitOr) (',' values+=BitOr)* )? ')')? /* we assume 0 as initial values for all cells */
	';'
;

//ListDeclaration returns List:
//	'list' name=FullyQualifiedName ('=' '(' ( (values+=BitOr) (',' values+=BitOr)* )? ')')? ';';

Event : Transition | Synchronization;

Transition:
	(comment=COMMENT)? 
	'transition' name=FullyQualifiedName 
	('(' params+=Parameter 	( ',' params+=Parameter)* ')')? 
	'[' guard=Or ']' 
	('label' label=Label)? 
	'{'
	(actions+=GalStatement)*
	'}';

Predicate:
	(comment=COMMENT)? 
	'predicate' name=FullyQualifiedName '=' value=Or  ';' 
;

AbstractParameter :
	Parameter | ConstParameter 
;

Parameter :
	type=[TypedefDeclaration] name=PARAMNAME
;

// A constant defined as type parameter or global specification level
ConstParameter : 
	name=PARAMNAME '=' value=Integer
;

GalStatement returns Statement :
	GalIte | Abort | Fixpoint | GalFor | SelfCall | Assignment 
;

CompStatement returns Statement :
	CompIte | Abort | CompFor | LabelCall
;


LabelCall :
	SelfCall | InstanceCall
;
// The statements, grammar rules are duplicated in places
// so that recursive parse into control structure (for, if)
//enforces type of statements encountered 


/*  ========= Transition Content ============ */
//Statement:	 Ite | Abort | Fixpoint | For | SelfCall | Assignment  | InstanceCall
//	| Push | Pop
//	;

//Push:
//	'push' '(' list=[List|FullyQualifiedName] ',' value=BitOr ')' ';';
//
//Pop:
//	'pop' '(' list=[List|FullyQualifiedName] ')' ';';

Assignment:
	(comment=COMMENT)? 	
   left=VariableReference type=AssignType right=BitOr ';';

enum AssignType :
	ASSIGN='='
	| INCR='+='
	| DECR='-='
;

InstanceCall:
		(comment=COMMENT)? 		
    instance=VariableReference '.' label=[Label|STRING] ('(' params+=BitOr (',' params+=BitOr)*    ')')? ';'
;

GalIte returns Ite:(comment=COMMENT)? 	
	'if' '(' cond=Or ')' '{' (ifTrue+=GalStatement)* '}'
	('else'  '{' (ifFalse+=GalStatement)*  '}')?	
;

CompIte returns Ite:(comment=COMMENT)? 	
	'if' '(' cond=Or ')' '{' (ifTrue+=CompStatement)* '}'
	('else'  '{' (ifFalse+=CompStatement)*  '}')?	
;

Fixpoint:
	{Fixpoint}
	(comment=COMMENT)? 	
	'fixpoint' '{' (actions+=GalStatement)* '}'
;


SelfCall:
	(comment=COMMENT)? 	
	'self' '.' label=[Label|STRING] ('(' params+=BitOr (',' params+=BitOr)*    ')')? ';';

Abort:
	{Abort} 
	(comment=COMMENT)? 	
	'abort' ';'
;

GalFor returns For: 
	(comment=COMMENT)? 		
	'for' '(' param=ForParameter ')' 
	'{'
		(actions+=GalStatement)*
	'}' 
;


CompFor returns For: 
	(comment=COMMENT)? 		
	'for' '(' param=ForParameter ')' 
	'{'
		(actions+=CompStatement)*
	'}' 
;

ForParameter returns Parameter: 
	name=PARAMNAME ':' type=[TypedefDeclaration] 
;

Reference :
VariableReference 
		(
			(-> ':' {QualifiedReference.qualifier=current} next=Reference )
			
		)? 	
;


VariableReference :
	ref=[NamedDeclaration|FullyQualifiedName] 
		(-> '[' index=BitOr ']' )?
;

ParamRef:
	refParam=[AbstractParameter|PARAMNAME]
;


/* ====   Properties  ========== */
Property : 'property' (name=ID | name=STRING) body=LogicProp ';' ;

LogicProp : ReachableProp | InvariantProp | NeverProp ;

ReachableProp : '[' 'reachable' ']'  ':' predicate=Or;

InvariantProp : '[' 'invariant' ']'  ':' predicate=Or;

NeverProp : '[' 'never' ']'  ':' predicate=Or;



/* =====   Arithmetic expressions ===== */

/* ====== Bitwise operators ======= */
// by order of increasing precedence
BitOr returns IntExpression:
	BitXor ({BinaryIntExpression.left=current} op='|' right=BitXor)*;

BitXor returns IntExpression:
	BitAnd ({BinaryIntExpression.left=current} op='^' right=BitAnd)*;

BitAnd returns IntExpression:
	BitShift ({BinaryIntExpression.left=current} op='&' right=BitShift)*;

BitShift returns IntExpression:
	Addition ({BinaryIntExpression.left=current} op=('<<' | '>>') right=Addition)*;

Addition returns IntExpression:
	Multiplication ({BinaryIntExpression.left=current} op=('+' | '-') right=Multiplication)*;

Multiplication returns IntExpression:
	UnaryExpr ({BinaryIntExpression.left=current} op=('/' | '*' | '%') right=UnaryExpr)*;

UnaryExpr returns IntExpression :
	BitComplement | UnaryMinus | Power
;

UnaryMinus returns IntExpression:
    {UnaryMinus} '-' value=UnaryExpr;
    
BitComplement returns IntExpression:
	{BitComplement} '~' value=UnaryExpr ;

Power returns IntExpression:
	Primary ({BinaryIntExpression.left=current} op=('**') right=Primary)*;

Primary returns IntExpression:
	Reference |
	ConstRef |
	(=> ('(' BitOr ')') | ('(' WrapBoolExpr ')'));

ConstRef returns IntExpression:
	Constant |
	ParamRef ;
	

WrapBoolExpr:
	value=Or;

Constant:
	value=INT;

//	| Peek  is a Primary
//Peek:
//	'peek' '(' list=[List|FullyQualifiedName] ')';

/* =====   Boolean expressions ===== */
enum ComparisonOperators:
	GT='>' | // Greater Thean
	LT='<' | // Lower Than
	GE='>=' | // Greater or Equal
	LE='<=' | // Lower or Equal
	EQ='==' | // Equal
	NE='!='; // Not Equal
	
Or returns BooleanExpression:
	(And ({Or.left=current} ->'||' right=And)*);

And returns BooleanExpression:
	Not ({And.left=current} ->'&&' right=Not)*;

Not returns BooleanExpression:
	(->'!' {Not} value=PrimaryBool) | PrimaryBool;

PrimaryBool returns BooleanExpression:
	True | False | => Comparison | ('(' Or ')');

Comparison:
	(left=BitOr
	->operator=ComparisonOperators
	right=BitOr);

True:
	{True}
	'true';

False:
	{False}
	'false';


ParamDef :
	param=[ConstParameter|PARAMNAME] '=' value=Integer 
;


InstanceDeclaration :
	type = [TypeDeclaration] name = FullyQualifiedName 
	( '(' paramDefs+=ParamDef  (',' paramDefs+=ParamDef )* ')' )? ';'
;

ArrayInstanceDeclaration :
	type = [TypeDeclaration] '[' size=BitOr ']'  name = FullyQualifiedName 
	( '(' paramDefs+=ParamDef  (',' paramDefs+=ParamDef )* ')' )? ';'
;


Synchronization:
	'synchronization' name = ID 
	('(' params+=Parameter 	( ',' params+=Parameter)* ')')? 	
	('label' label = Label)? '{'
		(actions+=CompStatement)*
	'}'
;



/* =====   Basic types ===== */


/** Overload and destroy XBase grammar rules */

XAssignment returns XExpression :
	{XAssignment} ;

XOrExpression returns XExpression:
	{XAssignment};

XAndExpression returns XExpression:
	{XAssignment};

XEqualityExpression returns XExpression:
{XAssignment};

XRelationalExpression returns XExpression:
{XAssignment};

XOtherOperatorExpression returns XExpression:
{XAssignment};

XAdditiveExpression returns XExpression:
{XAssignment};

XMultiplicativeExpression returns XExpression:
{XAssignment};

XUnaryOperation returns XExpression:
{XAssignment};

XCastedExpression returns XExpression:
{XAssignment};

XMemberFeatureCall returns XExpression:
{XAssignment};

XPrimaryExpression returns XExpression:
{XAssignment};

XLiteral returns XExpression:
{XAssignment};

XCollectionLiteral:XSetLiteral | XListLiteral;

XSetLiteral:{XSetLiteral};

XListLiteral:{XListLiteral};

XClosure returns XExpression:
{XAssignment};
	
XExpressionInClosure returns XExpression: 
{XAssignment};

XShortClosure returns XExpression:
{XAssignment};

XParenthesizedExpression returns XExpression:
{XAssignment};

XIfExpression returns XExpression:
{XAssignment};

XSwitchExpression returns XExpression:
{XAssignment};

XCasePart:
{XAssignment};

XForLoopExpression returns XExpression:
{XAssignment};

XWhileExpression returns XExpression:
{XAssignment};
	
XDoWhileExpression returns XExpression:
{XAssignment};

XBlockExpression returns XExpression: 
{XAssignment};

XExpressionInsideBlock returns XExpression:
{XAssignment};

XExpressionOrVarDeclaration returns XExpression:
{XAssignment};

XVariableDeclaration returns XExpression:
{XAssignment};

XFeatureCall returns XExpression:
{XAssignment};
	
FeatureCallID:
	ValidID 
;
	
XConstructorCall returns XExpression:
{XAssignment};

XBooleanLiteral returns XExpression :
{XAssignment};

XNullLiteral returns XExpression :
{XAssignment};

XNumberLiteral returns XExpression :
{XAssignment};

XStringLiteral returns XExpression:
{XAssignment};

XTypeLiteral returns XExpression :
{XAssignment};

XThrowExpression returns XExpression :
{XAssignment};
	
XReturnExpression returns XExpression :
{XAssignment};
	
XTryCatchFinallyExpression returns XExpression:
{XAssignment};
	
XCatchClause :
{XAssignment};

/* =====   Basic types ===== */

// This means a quoted "arbitrary #d%$ string"
Label :
	name=STRING ('(' params+=BitOr (',' params+=BitOr)*    ')')?
;

// Our qualified name may have integer at any position except first one
FullyQualifiedName:
	ID ( '.' (ID|INT))*
;

// semantic comments that can be added to model elements
terminal COMMENT :
	'/**' -> '*/' 
;
// override default behavior
terminal ML_COMMENT : 
	'xxxXXXxxx'
;
// Note that SL_COMMENT, i.e. "// to \n"
// comments to end of line
// it goes to hidden channel

// Start with $ and build an ID
terminal PARAMNAME:
	'$'  ('^')?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

// although we shoudl support parse of negative int, they will produce errors if output.
// please wrap any negative Constant value int in UnaryMinus.
Integer returns ecore::EInt:
	('-')? INT;
