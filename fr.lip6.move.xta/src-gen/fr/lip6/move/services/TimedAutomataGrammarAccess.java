/*
* generated by Xtext
*/
package fr.lip6.move.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class TimedAutomataGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class XTAElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "XTA");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cVariablesAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final RuleCall cVariablesVariableDeclParserRuleCall_0_0_0 = (RuleCall)cVariablesAssignment_0_0.eContents().get(0);
		private final Assignment cChannelsAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cChannelsChannelDeclParserRuleCall_0_1_0 = (RuleCall)cChannelsAssignment_0_1.eContents().get(0);
		private final Assignment cTypesAssignment_0_2 = (Assignment)cAlternatives_0.eContents().get(2);
		private final RuleCall cTypesTypeDeclParserRuleCall_0_2_0 = (RuleCall)cTypesAssignment_0_2.eContents().get(0);
		private final Assignment cTemplatesAssignment_0_3 = (Assignment)cAlternatives_0.eContents().get(3);
		private final RuleCall cTemplatesProcDeclParserRuleCall_0_3_0 = (RuleCall)cTemplatesAssignment_0_3.eContents().get(0);
		private final Assignment cInstancesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cInstancesInstanceParserRuleCall_1_0 = (RuleCall)cInstancesAssignment_1.eContents().get(0);
		private final Assignment cSystemAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSystemSystemParserRuleCall_2_0 = (RuleCall)cSystemAssignment_2.eContents().get(0);
		
		//XTA:
		//
		//	(variables+=VariableDecl | channels+=ChannelDecl | types+=TypeDecl | templates+=ProcDecl)* instances+=Instance*
		//
		//	system=System;
		public ParserRule getRule() { return rule; }

		//(variables+=VariableDecl | channels+=ChannelDecl | types+=TypeDecl | templates+=ProcDecl)* instances+=Instance*
		//
		//system=System
		public Group getGroup() { return cGroup; }

		//(variables+=VariableDecl | channels+=ChannelDecl | types+=TypeDecl | templates+=ProcDecl)*
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//variables+=VariableDecl
		public Assignment getVariablesAssignment_0_0() { return cVariablesAssignment_0_0; }

		//VariableDecl
		public RuleCall getVariablesVariableDeclParserRuleCall_0_0_0() { return cVariablesVariableDeclParserRuleCall_0_0_0; }

		//channels+=ChannelDecl
		public Assignment getChannelsAssignment_0_1() { return cChannelsAssignment_0_1; }

		//ChannelDecl
		public RuleCall getChannelsChannelDeclParserRuleCall_0_1_0() { return cChannelsChannelDeclParserRuleCall_0_1_0; }

		//types+=TypeDecl
		public Assignment getTypesAssignment_0_2() { return cTypesAssignment_0_2; }

		//TypeDecl
		public RuleCall getTypesTypeDeclParserRuleCall_0_2_0() { return cTypesTypeDeclParserRuleCall_0_2_0; }

		//templates+=ProcDecl
		public Assignment getTemplatesAssignment_0_3() { return cTemplatesAssignment_0_3; }

		//ProcDecl
		public RuleCall getTemplatesProcDeclParserRuleCall_0_3_0() { return cTemplatesProcDeclParserRuleCall_0_3_0; }

		//instances+=Instance*
		public Assignment getInstancesAssignment_1() { return cInstancesAssignment_1; }

		//Instance
		public RuleCall getInstancesInstanceParserRuleCall_1_0() { return cInstancesInstanceParserRuleCall_1_0; }

		//system=System
		public Assignment getSystemAssignment_2() { return cSystemAssignment_2; }

		//System
		public RuleCall getSystemSystemParserRuleCall_2_0() { return cSystemSystemParserRuleCall_2_0; }
	}

	public class InstantiableInSystemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InstantiableInSystem");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cInstanceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cProcDeclParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		////Declaration :
		//
		////// Functions are not supported yet.
		//
		//////	FunctionDecl | 
		//
		////	VariableDecl | ChannelDecl | TypeDecl | ProcDecl ;
		//
		//InstantiableInSystem:
		//
		//	Instance | ProcDecl;
		public ParserRule getRule() { return rule; }

		//Instance | ProcDecl
		public Alternatives getAlternatives() { return cAlternatives; }

		//Instance
		public RuleCall getInstanceParserRuleCall_0() { return cInstanceParserRuleCall_0; }

		//ProcDecl
		public RuleCall getProcDeclParserRuleCall_1() { return cProcDeclParserRuleCall_1; }
	}

	public class InstanceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Instance");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cASSIGNMENTParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTypeProcDeclCrossReference_2_0 = (CrossReference)cTypeAssignment_2.eContents().get(0);
		private final RuleCall cTypeProcDeclIDTerminalRuleCall_2_0_1 = (RuleCall)cTypeProcDeclCrossReference_2_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cArgsAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cArgsBitOrParserRuleCall_4_0_0 = (RuleCall)cArgsAssignment_4_0.eContents().get(0);
		private final Group cGroup_4_1 = (Group)cGroup_4.eContents().get(1);
		private final Keyword cCommaKeyword_4_1_0 = (Keyword)cGroup_4_1.eContents().get(0);
		private final Assignment cArgsAssignment_4_1_1 = (Assignment)cGroup_4_1.eContents().get(1);
		private final RuleCall cArgsBitOrParserRuleCall_4_1_1_0 = (RuleCall)cArgsAssignment_4_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//Instance:
		//
		//	name=ID ASSIGNMENT type=[ProcDecl] "(" (args+=BitOr ("," args+=BitOr)*)? ")" ";";
		public ParserRule getRule() { return rule; }

		//name=ID ASSIGNMENT type=[ProcDecl] "(" (args+=BitOr ("," args+=BitOr)*)? ")" ";"
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//ASSIGNMENT
		public RuleCall getASSIGNMENTParserRuleCall_1() { return cASSIGNMENTParserRuleCall_1; }

		//type=[ProcDecl]
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//[ProcDecl]
		public CrossReference getTypeProcDeclCrossReference_2_0() { return cTypeProcDeclCrossReference_2_0; }

		//ID
		public RuleCall getTypeProcDeclIDTerminalRuleCall_2_0_1() { return cTypeProcDeclIDTerminalRuleCall_2_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//(args+=BitOr ("," args+=BitOr)*)?
		public Group getGroup_4() { return cGroup_4; }

		//args+=BitOr
		public Assignment getArgsAssignment_4_0() { return cArgsAssignment_4_0; }

		//BitOr
		public RuleCall getArgsBitOrParserRuleCall_4_0_0() { return cArgsBitOrParserRuleCall_4_0_0; }

		//("," args+=BitOr)*
		public Group getGroup_4_1() { return cGroup_4_1; }

		//","
		public Keyword getCommaKeyword_4_1_0() { return cCommaKeyword_4_1_0; }

		//args+=BitOr
		public Assignment getArgsAssignment_4_1_1() { return cArgsAssignment_4_1_1; }

		//BitOr
		public RuleCall getArgsBitOrParserRuleCall_4_1_1_0() { return cArgsBitOrParserRuleCall_4_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class SystemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "System");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSystemKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cInstancesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cInstancesInstantiableInSystemCrossReference_1_0 = (CrossReference)cInstancesAssignment_1.eContents().get(0);
		private final RuleCall cInstancesInstantiableInSystemIDTerminalRuleCall_1_0_1 = (RuleCall)cInstancesInstantiableInSystemCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cInstancesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final CrossReference cInstancesInstantiableInSystemCrossReference_2_1_0 = (CrossReference)cInstancesAssignment_2_1.eContents().get(0);
		private final RuleCall cInstancesInstantiableInSystemIDTerminalRuleCall_2_1_0_1 = (RuleCall)cInstancesInstantiableInSystemCrossReference_2_1_0.eContents().get(1);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//System:
		//
		//	"system" instances+=[InstantiableInSystem] ("," instances+=[InstantiableInSystem])* ";";
		public ParserRule getRule() { return rule; }

		//"system" instances+=[InstantiableInSystem] ("," instances+=[InstantiableInSystem])* ";"
		public Group getGroup() { return cGroup; }

		//"system"
		public Keyword getSystemKeyword_0() { return cSystemKeyword_0; }

		//instances+=[InstantiableInSystem]
		public Assignment getInstancesAssignment_1() { return cInstancesAssignment_1; }

		//[InstantiableInSystem]
		public CrossReference getInstancesInstantiableInSystemCrossReference_1_0() { return cInstancesInstantiableInSystemCrossReference_1_0; }

		//ID
		public RuleCall getInstancesInstantiableInSystemIDTerminalRuleCall_1_0_1() { return cInstancesInstantiableInSystemIDTerminalRuleCall_1_0_1; }

		//("," instances+=[InstantiableInSystem])*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//instances+=[InstantiableInSystem]
		public Assignment getInstancesAssignment_2_1() { return cInstancesAssignment_2_1; }

		//[InstantiableInSystem]
		public CrossReference getInstancesInstantiableInSystemCrossReference_2_1_0() { return cInstancesInstantiableInSystemCrossReference_2_1_0; }

		//ID
		public RuleCall getInstancesInstantiableInSystemIDTerminalRuleCall_2_1_0_1() { return cInstancesInstantiableInSystemIDTerminalRuleCall_2_1_0_1; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ProcDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProcDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cProcessKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cParamsAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cParamsParameterParserRuleCall_3_0_0 = (RuleCall)cParamsAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cParamsAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cParamsParameterParserRuleCall_3_1_1_0 = (RuleCall)cParamsAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cLeftCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cBodyAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cBodyProcBodyParserRuleCall_6_0 = (RuleCall)cBodyAssignment_6.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//// FunctionDecl : type=Type name=ID (params=ParameterList) block=Block ;
		//
		//ProcDecl:
		//
		//	"process" name=ID "(" (params+=Parameter ("," params+=Parameter)*)? ")" "{" body=ProcBody "}";
		public ParserRule getRule() { return rule; }

		//"process" name=ID "(" (params+=Parameter ("," params+=Parameter)*)? ")" "{" body=ProcBody "}"
		public Group getGroup() { return cGroup; }

		//"process"
		public Keyword getProcessKeyword_0() { return cProcessKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//(params+=Parameter ("," params+=Parameter)*)?
		public Group getGroup_3() { return cGroup_3; }

		//params+=Parameter
		public Assignment getParamsAssignment_3_0() { return cParamsAssignment_3_0; }

		//Parameter
		public RuleCall getParamsParameterParserRuleCall_3_0_0() { return cParamsParameterParserRuleCall_3_0_0; }

		//("," params+=Parameter)*
		public Group getGroup_3_1() { return cGroup_3_1; }

		//","
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }

		//params+=Parameter
		public Assignment getParamsAssignment_3_1_1() { return cParamsAssignment_3_1_1; }

		//Parameter
		public RuleCall getParamsParameterParserRuleCall_3_1_1_0() { return cParamsParameterParserRuleCall_3_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_5() { return cLeftCurlyBracketKeyword_5; }

		//body=ProcBody
		public Assignment getBodyAssignment_6() { return cBodyAssignment_6; }

		//ProcBody
		public RuleCall getBodyProcBodyParserRuleCall_6_0() { return cBodyProcBodyParserRuleCall_6_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}

	public class FormalDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FormalDeclaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cParameterParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDeclIdParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//FormalDeclaration:
		//
		//	Parameter | DeclId;
		public ParserRule getRule() { return rule; }

		//Parameter | DeclId
		public Alternatives getAlternatives() { return cAlternatives; }

		//Parameter
		public RuleCall getParameterParserRuleCall_0() { return cParameterParserRuleCall_0; }

		//DeclId
		public RuleCall getDeclIdParserRuleCall_1() { return cDeclIdParserRuleCall_1; }
	}

	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Parameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeTypeParserRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//// (vals+=ArrayDecl)* // not sure what this is about, no example in doc.
		//
		//Parameter:
		//
		//	type=Type //	('&')?  // call by reference is not supported as we do macro substitute for constant parameters only
		//
		//	name=ID;
		public ParserRule getRule() { return rule; }

		//type=Type //	('&')?  // call by reference is not supported as we do macro substitute for constant parameters only
		//
		//name=ID
		public Group getGroup() { return cGroup; }

		//type=Type
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_0_0() { return cTypeTypeParserRuleCall_0_0; }

		////	('&')?  // call by reference is not supported as we do macro substitute for constant parameters only
		//
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}

	public class TypeDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTypedefKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeTypeParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//TypeDecl:
		//
		//	"typedef" type=Type name=ID // (',' ids+=TypeIdList)*  // We only support one typedef at a time.
		//
		//	";";
		public ParserRule getRule() { return rule; }

		//"typedef" type=Type name=ID // (',' ids+=TypeIdList)*  // We only support one typedef at a time.
		//
		//";"
		public Group getGroup() { return cGroup; }

		//"typedef"
		public Keyword getTypedefKeyword_0() { return cTypedefKeyword_0; }

		//type=Type
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_1_0() { return cTypeTypeParserRuleCall_1_0; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//// (',' ids+=TypeIdList)*  // We only support one typedef at a time.
		//
		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBasicTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypedefRefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Type:
		//
		//	BasicType | TypedefRef;
		public ParserRule getRule() { return rule; }

		//BasicType | TypedefRef
		public Alternatives getAlternatives() { return cAlternatives; }

		//BasicType
		public RuleCall getBasicTypeParserRuleCall_0() { return cBasicTypeParserRuleCall_0; }

		//TypedefRef
		public RuleCall getTypedefRefParserRuleCall_1() { return cTypedefRefParserRuleCall_1; }
	}

	public class BasicTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BasicType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntegerTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBoolTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cClockTypeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cRangeTypeParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//// or struct
		//
		//BasicType:
		//
		//	IntegerType | BoolType | ClockType | RangeType;
		public ParserRule getRule() { return rule; }

		//IntegerType | BoolType | ClockType | RangeType
		public Alternatives getAlternatives() { return cAlternatives; }

		//IntegerType
		public RuleCall getIntegerTypeParserRuleCall_0() { return cIntegerTypeParserRuleCall_0; }

		//BoolType
		public RuleCall getBoolTypeParserRuleCall_1() { return cBoolTypeParserRuleCall_1; }

		//ClockType
		public RuleCall getClockTypeParserRuleCall_2() { return cClockTypeParserRuleCall_2; }

		//RangeType
		public RuleCall getRangeTypeParserRuleCall_3() { return cRangeTypeParserRuleCall_3; }
	}

	public class TypedefRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypedefRef");
		private final Assignment cRefAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cRefTypeDeclCrossReference_0 = (CrossReference)cRefAssignment.eContents().get(0);
		private final RuleCall cRefTypeDeclIDTerminalRuleCall_0_1 = (RuleCall)cRefTypeDeclCrossReference_0.eContents().get(1);
		
		//// ChannelType |
		//
		//TypedefRef:
		//
		//	ref=[TypeDecl];
		public ParserRule getRule() { return rule; }

		//ref=[TypeDecl]
		public Assignment getRefAssignment() { return cRefAssignment; }

		//[TypeDecl]
		public CrossReference getRefTypeDeclCrossReference_0() { return cRefTypeDeclCrossReference_0; }

		//ID
		public RuleCall getRefTypeDeclIDTerminalRuleCall_0_1() { return cRefTypeDeclIDTerminalRuleCall_0_1; }
	}

	public class ChannelDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ChannelDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cChannelTypeParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cChansAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cChansChanIdParserRuleCall_1_0 = (RuleCall)cChansAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cChansAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cChansChanIdParserRuleCall_2_1_0 = (RuleCall)cChansAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ChannelDecl:
		//
		//	ChannelType chans+=ChanId ("," chans+=ChanId)* ";";
		public ParserRule getRule() { return rule; }

		//ChannelType chans+=ChanId ("," chans+=ChanId)* ";"
		public Group getGroup() { return cGroup; }

		//ChannelType
		public RuleCall getChannelTypeParserRuleCall_0() { return cChannelTypeParserRuleCall_0; }

		//chans+=ChanId
		public Assignment getChansAssignment_1() { return cChansAssignment_1; }

		//ChanId
		public RuleCall getChansChanIdParserRuleCall_1_0() { return cChansChanIdParserRuleCall_1_0; }

		//("," chans+=ChanId)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//chans+=ChanId
		public Assignment getChansAssignment_2_1() { return cChansAssignment_2_1; }

		//ChanId
		public RuleCall getChansChanIdParserRuleCall_2_1_0() { return cChansChanIdParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ChanIdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ChanId");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//ChanId:
		//
		//	name=ID;
		public ParserRule getRule() { return rule; }

		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}

	public class ChannelTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ChannelType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cChannelTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cChanKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cUrgentAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cUrgentUrgentKeyword_2_0 = (Keyword)cUrgentAssignment_2.eContents().get(0);
		private final Assignment cBroadcastAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Keyword cBroadcastBroadcastKeyword_3_0 = (Keyword)cBroadcastAssignment_3.eContents().get(0);
		
		//ChannelType:
		//
		//	{ChannelType} "chan" urgent?="urgent"? broadcast?="broadcast"?;
		public ParserRule getRule() { return rule; }

		//{ChannelType} "chan" urgent?="urgent"? broadcast?="broadcast"?
		public Group getGroup() { return cGroup; }

		//{ChannelType}
		public Action getChannelTypeAction_0() { return cChannelTypeAction_0; }

		//"chan"
		public Keyword getChanKeyword_1() { return cChanKeyword_1; }

		//urgent?="urgent"?
		public Assignment getUrgentAssignment_2() { return cUrgentAssignment_2; }

		//"urgent"
		public Keyword getUrgentUrgentKeyword_2_0() { return cUrgentUrgentKeyword_2_0; }

		//broadcast?="broadcast"?
		public Assignment getBroadcastAssignment_3() { return cBroadcastAssignment_3; }

		//"broadcast"
		public Keyword getBroadcastBroadcastKeyword_3_0() { return cBroadcastBroadcastKeyword_3_0; }
	}

	public class IntegerTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntegerType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIntegerTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cConstAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cConstConstKeyword_1_0 = (Keyword)cConstAssignment_1.eContents().get(0);
		private final Keyword cIntKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//IntegerType:
		//
		//	{IntegerType} const?="const"? "int";
		public ParserRule getRule() { return rule; }

		//{IntegerType} const?="const"? "int"
		public Group getGroup() { return cGroup; }

		//{IntegerType}
		public Action getIntegerTypeAction_0() { return cIntegerTypeAction_0; }

		//const?="const"?
		public Assignment getConstAssignment_1() { return cConstAssignment_1; }

		//"const"
		public Keyword getConstConstKeyword_1_0() { return cConstConstKeyword_1_0; }

		//"int"
		public Keyword getIntKeyword_2() { return cIntKeyword_2; }
	}

	public class BoolTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BoolType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBoolTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cConstAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cConstConstKeyword_1_0 = (Keyword)cConstAssignment_1.eContents().get(0);
		private final Keyword cBoolKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//BoolType:
		//
		//	{BoolType} const?="const"? "bool";
		public ParserRule getRule() { return rule; }

		//{BoolType} const?="const"? "bool"
		public Group getGroup() { return cGroup; }

		//{BoolType}
		public Action getBoolTypeAction_0() { return cBoolTypeAction_0; }

		//const?="const"?
		public Assignment getConstAssignment_1() { return cConstAssignment_1; }

		//"const"
		public Keyword getConstConstKeyword_1_0() { return cConstConstKeyword_1_0; }

		//"bool"
		public Keyword getBoolKeyword_2() { return cBoolKeyword_2; }
	}

	public class RangeTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RangeType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConstAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cConstConstKeyword_0_0 = (Keyword)cConstAssignment_0.eContents().get(0);
		private final Keyword cIntKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cMinAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cMinINTTerminalRuleCall_3_0 = (RuleCall)cMinAssignment_3.eContents().get(0);
		private final Keyword cCommaKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cMaxAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cMaxINTTerminalRuleCall_5_0 = (RuleCall)cMaxAssignment_5.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//// these INT should be expressions in general
		//
		//RangeType:
		//
		//	const?="const"? "int" "[" min=INT "," max=INT "]";
		public ParserRule getRule() { return rule; }

		//const?="const"? "int" "[" min=INT "," max=INT "]"
		public Group getGroup() { return cGroup; }

		//const?="const"?
		public Assignment getConstAssignment_0() { return cConstAssignment_0; }

		//"const"
		public Keyword getConstConstKeyword_0_0() { return cConstConstKeyword_0_0; }

		//"int"
		public Keyword getIntKeyword_1() { return cIntKeyword_1; }

		//"["
		public Keyword getLeftSquareBracketKeyword_2() { return cLeftSquareBracketKeyword_2; }

		//min=INT
		public Assignment getMinAssignment_3() { return cMinAssignment_3; }

		//INT
		public RuleCall getMinINTTerminalRuleCall_3_0() { return cMinINTTerminalRuleCall_3_0; }

		//","
		public Keyword getCommaKeyword_4() { return cCommaKeyword_4; }

		//max=INT
		public Assignment getMaxAssignment_5() { return cMaxAssignment_5; }

		//INT
		public RuleCall getMaxINTTerminalRuleCall_5_0() { return cMaxINTTerminalRuleCall_5_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_6() { return cRightSquareBracketKeyword_6; }
	}

	public class ClockTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClockType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cClockTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cClockKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//ClockType:
		//
		//	{ClockType} "clock";
		public ParserRule getRule() { return rule; }

		//{ClockType} "clock"
		public Group getGroup() { return cGroup; }

		//{ClockType}
		public Action getClockTypeAction_0() { return cClockTypeAction_0; }

		//"clock"
		public Keyword getClockKeyword_1() { return cClockKeyword_1; }
	}

	public class ProcBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProcBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cVariablesAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final RuleCall cVariablesVariableDeclParserRuleCall_0_0_0 = (RuleCall)cVariablesAssignment_0_0.eContents().get(0);
		private final Assignment cTypesAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cTypesTypeDeclParserRuleCall_0_1_0 = (RuleCall)cTypesAssignment_0_1.eContents().get(0);
		private final Keyword cStateKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStatesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatesStateDeclParserRuleCall_2_0 = (RuleCall)cStatesAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cStatesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cStatesStateDeclParserRuleCall_3_1_0 = (RuleCall)cStatesAssignment_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cCommitKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cCommitStatesAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final CrossReference cCommitStatesStateDeclCrossReference_5_1_0 = (CrossReference)cCommitStatesAssignment_5_1.eContents().get(0);
		private final RuleCall cCommitStatesStateDeclIDTerminalRuleCall_5_1_0_1 = (RuleCall)cCommitStatesStateDeclCrossReference_5_1_0.eContents().get(1);
		private final Group cGroup_5_2 = (Group)cGroup_5.eContents().get(2);
		private final Keyword cCommaKeyword_5_2_0 = (Keyword)cGroup_5_2.eContents().get(0);
		private final Assignment cCommitStatesAssignment_5_2_1 = (Assignment)cGroup_5_2.eContents().get(1);
		private final CrossReference cCommitStatesStateDeclCrossReference_5_2_1_0 = (CrossReference)cCommitStatesAssignment_5_2_1.eContents().get(0);
		private final RuleCall cCommitStatesStateDeclIDTerminalRuleCall_5_2_1_0_1 = (RuleCall)cCommitStatesStateDeclCrossReference_5_2_1_0.eContents().get(1);
		private final Keyword cSemicolonKeyword_5_3 = (Keyword)cGroup_5.eContents().get(3);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cUrgentKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cUrgentStatesAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final CrossReference cUrgentStatesStateDeclCrossReference_6_1_0 = (CrossReference)cUrgentStatesAssignment_6_1.eContents().get(0);
		private final RuleCall cUrgentStatesStateDeclIDTerminalRuleCall_6_1_0_1 = (RuleCall)cUrgentStatesStateDeclCrossReference_6_1_0.eContents().get(1);
		private final Group cGroup_6_2 = (Group)cGroup_6.eContents().get(2);
		private final Keyword cCommaKeyword_6_2_0 = (Keyword)cGroup_6_2.eContents().get(0);
		private final Assignment cUrgentStatesAssignment_6_2_1 = (Assignment)cGroup_6_2.eContents().get(1);
		private final CrossReference cUrgentStatesStateDeclCrossReference_6_2_1_0 = (CrossReference)cUrgentStatesAssignment_6_2_1.eContents().get(0);
		private final RuleCall cUrgentStatesStateDeclIDTerminalRuleCall_6_2_1_0_1 = (RuleCall)cUrgentStatesStateDeclCrossReference_6_2_1_0.eContents().get(1);
		private final Keyword cSemicolonKeyword_6_3 = (Keyword)cGroup_6.eContents().get(3);
		private final Keyword cInitKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cInitStateAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final CrossReference cInitStateStateDeclCrossReference_8_0 = (CrossReference)cInitStateAssignment_8.eContents().get(0);
		private final RuleCall cInitStateStateDeclIDTerminalRuleCall_8_0_1 = (RuleCall)cInitStateStateDeclCrossReference_8_0.eContents().get(1);
		private final Keyword cSemicolonKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final Group cGroup_10 = (Group)cGroup.eContents().get(10);
		private final Keyword cTransKeyword_10_0 = (Keyword)cGroup_10.eContents().get(0);
		private final Assignment cTransitionsAssignment_10_1 = (Assignment)cGroup_10.eContents().get(1);
		private final RuleCall cTransitionsTransitionParserRuleCall_10_1_0 = (RuleCall)cTransitionsAssignment_10_1.eContents().get(0);
		private final Group cGroup_10_2 = (Group)cGroup_10.eContents().get(2);
		private final Keyword cCommaKeyword_10_2_0 = (Keyword)cGroup_10_2.eContents().get(0);
		private final Assignment cTransitionsAssignment_10_2_1 = (Assignment)cGroup_10_2.eContents().get(1);
		private final RuleCall cTransitionsTransitionParserRuleCall_10_2_1_0 = (RuleCall)cTransitionsAssignment_10_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_10_3 = (Keyword)cGroup_10.eContents().get(3);
		
		//// struct declarations not supported yet
		//
		////     |  prefix=Prefix 'struct' '{' fields+=FieldDecl+ '}' 
		//
		//// structs are not supported
		//
		//// FieldDecl : type=Type ids+=FieldDeclId (',' ids+=FieldDeclId)* ';' ;
		//
		////    
		//
		//// FieldDeclId : name=ID arrays+=ArrayDecl* ;
		//
		//ProcBody: // functions are not supported yet
		//
		//// functions+=FunctionDecl | 
		//
		//	(variables+=VariableDecl | types+=TypeDecl)* "state" states+=StateDecl ("," states+=StateDecl)* ";" ("commit"
		//
		//	commitStates+=[StateDecl] ("," commitStates+=[StateDecl])* ";")? ("urgent" urgentStates+=[StateDecl] (","
		//
		//	urgentStates+=[StateDecl])* ";")? "init" initState=[StateDecl] ";" ("trans" transitions+=Transition (","
		//
		//	transitions+=Transition)* ";");
		public ParserRule getRule() { return rule; }

		//// functions are not supported yet
		//
		//// functions+=FunctionDecl | 
		//
		//(variables+=VariableDecl | types+=TypeDecl)* "state" states+=StateDecl ("," states+=StateDecl)* ";" ("commit"
		//
		//commitStates+=[StateDecl] ("," commitStates+=[StateDecl])* ";")? ("urgent" urgentStates+=[StateDecl] (","
		//
		//urgentStates+=[StateDecl])* ";")? "init" initState=[StateDecl] ";" ("trans" transitions+=Transition (","
		//
		//transitions+=Transition)* ";")
		public Group getGroup() { return cGroup; }

		//// functions are not supported yet
		//
		//// functions+=FunctionDecl | 
		//
		//(variables+=VariableDecl | types+=TypeDecl)*
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//// functions are not supported yet
		//
		//// functions+=FunctionDecl | 
		//
		//variables+=VariableDecl
		public Assignment getVariablesAssignment_0_0() { return cVariablesAssignment_0_0; }

		//VariableDecl
		public RuleCall getVariablesVariableDeclParserRuleCall_0_0_0() { return cVariablesVariableDeclParserRuleCall_0_0_0; }

		//types+=TypeDecl
		public Assignment getTypesAssignment_0_1() { return cTypesAssignment_0_1; }

		//TypeDecl
		public RuleCall getTypesTypeDeclParserRuleCall_0_1_0() { return cTypesTypeDeclParserRuleCall_0_1_0; }

		//"state"
		public Keyword getStateKeyword_1() { return cStateKeyword_1; }

		//states+=StateDecl
		public Assignment getStatesAssignment_2() { return cStatesAssignment_2; }

		//StateDecl
		public RuleCall getStatesStateDeclParserRuleCall_2_0() { return cStatesStateDeclParserRuleCall_2_0; }

		//("," states+=StateDecl)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//states+=StateDecl
		public Assignment getStatesAssignment_3_1() { return cStatesAssignment_3_1; }

		//StateDecl
		public RuleCall getStatesStateDeclParserRuleCall_3_1_0() { return cStatesStateDeclParserRuleCall_3_1_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }

		//("commit" commitStates+=[StateDecl] ("," commitStates+=[StateDecl])* ";")?
		public Group getGroup_5() { return cGroup_5; }

		//"commit"
		public Keyword getCommitKeyword_5_0() { return cCommitKeyword_5_0; }

		//commitStates+=[StateDecl]
		public Assignment getCommitStatesAssignment_5_1() { return cCommitStatesAssignment_5_1; }

		//[StateDecl]
		public CrossReference getCommitStatesStateDeclCrossReference_5_1_0() { return cCommitStatesStateDeclCrossReference_5_1_0; }

		//ID
		public RuleCall getCommitStatesStateDeclIDTerminalRuleCall_5_1_0_1() { return cCommitStatesStateDeclIDTerminalRuleCall_5_1_0_1; }

		//("," commitStates+=[StateDecl])*
		public Group getGroup_5_2() { return cGroup_5_2; }

		//","
		public Keyword getCommaKeyword_5_2_0() { return cCommaKeyword_5_2_0; }

		//commitStates+=[StateDecl]
		public Assignment getCommitStatesAssignment_5_2_1() { return cCommitStatesAssignment_5_2_1; }

		//[StateDecl]
		public CrossReference getCommitStatesStateDeclCrossReference_5_2_1_0() { return cCommitStatesStateDeclCrossReference_5_2_1_0; }

		//ID
		public RuleCall getCommitStatesStateDeclIDTerminalRuleCall_5_2_1_0_1() { return cCommitStatesStateDeclIDTerminalRuleCall_5_2_1_0_1; }

		//";"
		public Keyword getSemicolonKeyword_5_3() { return cSemicolonKeyword_5_3; }

		//("urgent" urgentStates+=[StateDecl] ("," urgentStates+=[StateDecl])* ";")?
		public Group getGroup_6() { return cGroup_6; }

		//"urgent"
		public Keyword getUrgentKeyword_6_0() { return cUrgentKeyword_6_0; }

		//urgentStates+=[StateDecl]
		public Assignment getUrgentStatesAssignment_6_1() { return cUrgentStatesAssignment_6_1; }

		//[StateDecl]
		public CrossReference getUrgentStatesStateDeclCrossReference_6_1_0() { return cUrgentStatesStateDeclCrossReference_6_1_0; }

		//ID
		public RuleCall getUrgentStatesStateDeclIDTerminalRuleCall_6_1_0_1() { return cUrgentStatesStateDeclIDTerminalRuleCall_6_1_0_1; }

		//("," urgentStates+=[StateDecl])*
		public Group getGroup_6_2() { return cGroup_6_2; }

		//","
		public Keyword getCommaKeyword_6_2_0() { return cCommaKeyword_6_2_0; }

		//urgentStates+=[StateDecl]
		public Assignment getUrgentStatesAssignment_6_2_1() { return cUrgentStatesAssignment_6_2_1; }

		//[StateDecl]
		public CrossReference getUrgentStatesStateDeclCrossReference_6_2_1_0() { return cUrgentStatesStateDeclCrossReference_6_2_1_0; }

		//ID
		public RuleCall getUrgentStatesStateDeclIDTerminalRuleCall_6_2_1_0_1() { return cUrgentStatesStateDeclIDTerminalRuleCall_6_2_1_0_1; }

		//";"
		public Keyword getSemicolonKeyword_6_3() { return cSemicolonKeyword_6_3; }

		//"init"
		public Keyword getInitKeyword_7() { return cInitKeyword_7; }

		//initState=[StateDecl]
		public Assignment getInitStateAssignment_8() { return cInitStateAssignment_8; }

		//[StateDecl]
		public CrossReference getInitStateStateDeclCrossReference_8_0() { return cInitStateStateDeclCrossReference_8_0; }

		//ID
		public RuleCall getInitStateStateDeclIDTerminalRuleCall_8_0_1() { return cInitStateStateDeclIDTerminalRuleCall_8_0_1; }

		//";"
		public Keyword getSemicolonKeyword_9() { return cSemicolonKeyword_9; }

		//"trans" transitions+=Transition ("," transitions+=Transition)* ";"
		public Group getGroup_10() { return cGroup_10; }

		//"trans"
		public Keyword getTransKeyword_10_0() { return cTransKeyword_10_0; }

		//transitions+=Transition
		public Assignment getTransitionsAssignment_10_1() { return cTransitionsAssignment_10_1; }

		//Transition
		public RuleCall getTransitionsTransitionParserRuleCall_10_1_0() { return cTransitionsTransitionParserRuleCall_10_1_0; }

		//("," transitions+=Transition)*
		public Group getGroup_10_2() { return cGroup_10_2; }

		//","
		public Keyword getCommaKeyword_10_2_0() { return cCommaKeyword_10_2_0; }

		//transitions+=Transition
		public Assignment getTransitionsAssignment_10_2_1() { return cTransitionsAssignment_10_2_1; }

		//Transition
		public RuleCall getTransitionsTransitionParserRuleCall_10_2_1_0() { return cTransitionsTransitionParserRuleCall_10_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_10_3() { return cSemicolonKeyword_10_3; }
	}

	public class StateDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StateDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cInvariantAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cInvariantOrParserRuleCall_1_1_0 = (RuleCall)cInvariantAssignment_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//StateDecl:
		//
		//	name=ID ("{" invariant=Or "}")?;
		public ParserRule getRule() { return rule; }

		//name=ID ("{" invariant=Or "}")?
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//("{" invariant=Or "}")?
		public Group getGroup_1() { return cGroup_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1_0() { return cLeftCurlyBracketKeyword_1_0; }

		//invariant=Or
		public Assignment getInvariantAssignment_1_1() { return cInvariantAssignment_1_1; }

		//Or
		public RuleCall getInvariantOrParserRuleCall_1_1_0() { return cInvariantOrParserRuleCall_1_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_1_2() { return cRightCurlyBracketKeyword_1_2; }
	}

	public class TransitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Transition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSrcAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cSrcStateDeclCrossReference_0_0 = (CrossReference)cSrcAssignment_0.eContents().get(0);
		private final RuleCall cSrcStateDeclIDTerminalRuleCall_0_0_1 = (RuleCall)cSrcStateDeclCrossReference_0_0.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDestAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cDestStateDeclCrossReference_2_0 = (CrossReference)cDestAssignment_2.eContents().get(0);
		private final RuleCall cDestStateDeclIDTerminalRuleCall_2_0_1 = (RuleCall)cDestStateDeclCrossReference_2_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cGuardKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cGuardAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cGuardOrParserRuleCall_4_1_0 = (RuleCall)cGuardAssignment_4_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		private final Assignment cSyncAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cSyncSyncParserRuleCall_5_0 = (RuleCall)cSyncAssignment_5.eContents().get(0);
		private final Assignment cAssignAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cAssignAssignmentsParserRuleCall_6_0 = (RuleCall)cAssignAssignment_6.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//Transition:
		//
		//	src=[StateDecl] "->" dest=[StateDecl] "{" ("guard" guard=Or ";")? sync=Sync? assign=Assignments? "}";
		public ParserRule getRule() { return rule; }

		//src=[StateDecl] "->" dest=[StateDecl] "{" ("guard" guard=Or ";")? sync=Sync? assign=Assignments? "}"
		public Group getGroup() { return cGroup; }

		//src=[StateDecl]
		public Assignment getSrcAssignment_0() { return cSrcAssignment_0; }

		//[StateDecl]
		public CrossReference getSrcStateDeclCrossReference_0_0() { return cSrcStateDeclCrossReference_0_0; }

		//ID
		public RuleCall getSrcStateDeclIDTerminalRuleCall_0_0_1() { return cSrcStateDeclIDTerminalRuleCall_0_0_1; }

		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_1() { return cHyphenMinusGreaterThanSignKeyword_1; }

		//dest=[StateDecl]
		public Assignment getDestAssignment_2() { return cDestAssignment_2; }

		//[StateDecl]
		public CrossReference getDestStateDeclCrossReference_2_0() { return cDestStateDeclCrossReference_2_0; }

		//ID
		public RuleCall getDestStateDeclIDTerminalRuleCall_2_0_1() { return cDestStateDeclIDTerminalRuleCall_2_0_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//("guard" guard=Or ";")?
		public Group getGroup_4() { return cGroup_4; }

		//"guard"
		public Keyword getGuardKeyword_4_0() { return cGuardKeyword_4_0; }

		//guard=Or
		public Assignment getGuardAssignment_4_1() { return cGuardAssignment_4_1; }

		//Or
		public RuleCall getGuardOrParserRuleCall_4_1_0() { return cGuardOrParserRuleCall_4_1_0; }

		//";"
		public Keyword getSemicolonKeyword_4_2() { return cSemicolonKeyword_4_2; }

		//sync=Sync?
		public Assignment getSyncAssignment_5() { return cSyncAssignment_5; }

		//Sync
		public RuleCall getSyncSyncParserRuleCall_5_0() { return cSyncSyncParserRuleCall_5_0; }

		//assign=Assignments?
		public Assignment getAssignAssignment_6() { return cAssignAssignment_6; }

		//Assignments
		public RuleCall getAssignAssignmentsParserRuleCall_6_0() { return cAssignAssignmentsParserRuleCall_6_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}

	public class SyncElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Sync");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSendParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRecvParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// ignore this feature of many outgoing edges, it doesn(t appear in the examples
		//
		//// TransitionOpt : Transition | '->' dest=[StateDecl] body=TransitionBody ;
		//
		//Sync:
		//
		//	Send | Recv;
		public ParserRule getRule() { return rule; }

		//Send | Recv
		public Alternatives getAlternatives() { return cAlternatives; }

		//Send
		public RuleCall getSendParserRuleCall_0() { return cSendParserRuleCall_0; }

		//Recv
		public RuleCall getRecvParserRuleCall_1() { return cRecvParserRuleCall_1; }
	}

	public class SendElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Send");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSyncKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cChannelAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cChannelChanIdCrossReference_1_0 = (CrossReference)cChannelAssignment_1.eContents().get(0);
		private final RuleCall cChannelChanIdIDTerminalRuleCall_1_0_1 = (RuleCall)cChannelChanIdCrossReference_1_0.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// we need a ChannelDecl metaclass to force correct usage
		//
		//Send:
		//
		//	"sync" channel=[ChanId] "!" ";";
		public ParserRule getRule() { return rule; }

		//"sync" channel=[ChanId] "!" ";"
		public Group getGroup() { return cGroup; }

		//"sync"
		public Keyword getSyncKeyword_0() { return cSyncKeyword_0; }

		//channel=[ChanId]
		public Assignment getChannelAssignment_1() { return cChannelAssignment_1; }

		//[ChanId]
		public CrossReference getChannelChanIdCrossReference_1_0() { return cChannelChanIdCrossReference_1_0; }

		//ID
		public RuleCall getChannelChanIdIDTerminalRuleCall_1_0_1() { return cChannelChanIdIDTerminalRuleCall_1_0_1; }

		//"!"
		public Keyword getExclamationMarkKeyword_2() { return cExclamationMarkKeyword_2; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class RecvElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Recv");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSyncKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cChannelAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cChannelChanIdCrossReference_1_0 = (CrossReference)cChannelAssignment_1.eContents().get(0);
		private final RuleCall cChannelChanIdIDTerminalRuleCall_1_0_1 = (RuleCall)cChannelChanIdCrossReference_1_0.eContents().get(1);
		private final Keyword cQuestionMarkKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Recv:
		//
		//	"sync" channel=[ChanId] "?" ";";
		public ParserRule getRule() { return rule; }

		//"sync" channel=[ChanId] "?" ";"
		public Group getGroup() { return cGroup; }

		//"sync"
		public Keyword getSyncKeyword_0() { return cSyncKeyword_0; }

		//channel=[ChanId]
		public Assignment getChannelAssignment_1() { return cChannelAssignment_1; }

		//[ChanId]
		public CrossReference getChannelChanIdCrossReference_1_0() { return cChannelChanIdCrossReference_1_0; }

		//ID
		public RuleCall getChannelChanIdIDTerminalRuleCall_1_0_1() { return cChannelChanIdIDTerminalRuleCall_1_0_1; }

		//"?"
		public Keyword getQuestionMarkKeyword_2() { return cQuestionMarkKeyword_2; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class AssignmentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Assignments");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAssignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cAssignsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAssignsAssignParserRuleCall_1_0 = (RuleCall)cAssignsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cAssignsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cAssignsAssignParserRuleCall_2_1_0 = (RuleCall)cAssignsAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Assignments:
		//
		//	"assign" assigns+=Assign ("," assigns+=Assign)* ";";
		public ParserRule getRule() { return rule; }

		//"assign" assigns+=Assign ("," assigns+=Assign)* ";"
		public Group getGroup() { return cGroup; }

		//"assign"
		public Keyword getAssignKeyword_0() { return cAssignKeyword_0; }

		//assigns+=Assign
		public Assignment getAssignsAssignment_1() { return cAssignsAssignment_1; }

		//Assign
		public RuleCall getAssignsAssignParserRuleCall_1_0() { return cAssignsAssignParserRuleCall_1_0; }

		//("," assigns+=Assign)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//assigns+=Assign
		public Assignment getAssignsAssignment_2_1() { return cAssignsAssignment_2_1; }

		//Assign
		public RuleCall getAssignsAssignParserRuleCall_2_1_0() { return cAssignsAssignParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class AssignElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Assign");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsVarAccessParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final RuleCall cASSIGNMENTParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cRhsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRhsBitOrParserRuleCall_2_0 = (RuleCall)cRhsAssignment_2.eContents().get(0);
		
		//Assign:
		//
		//	lhs=VarAccess ASSIGNMENT rhs=BitOr;
		public ParserRule getRule() { return rule; }

		//lhs=VarAccess ASSIGNMENT rhs=BitOr
		public Group getGroup() { return cGroup; }

		//lhs=VarAccess
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//VarAccess
		public RuleCall getLhsVarAccessParserRuleCall_0_0() { return cLhsVarAccessParserRuleCall_0_0; }

		//ASSIGNMENT
		public RuleCall getASSIGNMENTParserRuleCall_1() { return cASSIGNMENTParserRuleCall_1; }

		//rhs=BitOr
		public Assignment getRhsAssignment_2() { return cRhsAssignment_2; }

		//BitOr
		public RuleCall getRhsBitOrParserRuleCall_2_0() { return cRhsBitOrParserRuleCall_2_0; }
	}

	public class VariableDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeBasicTypeParserRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cDeclidAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDeclidDeclIdParserRuleCall_1_0 = (RuleCall)cDeclidAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cDeclidAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cDeclidDeclIdParserRuleCall_2_1_0 = (RuleCall)cDeclidAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// TypeIdList : name=ID arrays+=ArrayDecl* ;
		//
		///// BNF for variable declarations
		//
		//VariableDecl:
		//
		//	type=BasicType declid+=DeclId ("," declid+=DeclId)* ";";
		public ParserRule getRule() { return rule; }

		//type=BasicType declid+=DeclId ("," declid+=DeclId)* ";"
		public Group getGroup() { return cGroup; }

		//type=BasicType
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }

		//BasicType
		public RuleCall getTypeBasicTypeParserRuleCall_0_0() { return cTypeBasicTypeParserRuleCall_0_0; }

		//declid+=DeclId
		public Assignment getDeclidAssignment_1() { return cDeclidAssignment_1; }

		//DeclId
		public RuleCall getDeclidDeclIdParserRuleCall_1_0() { return cDeclidDeclIdParserRuleCall_1_0; }

		//("," declid+=DeclId)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//declid+=DeclId
		public Assignment getDeclidAssignment_2_1() { return cDeclidAssignment_2_1; }

		//DeclId
		public RuleCall getDeclidDeclIdParserRuleCall_2_1_0() { return cDeclidDeclIdParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class DeclIdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DeclId");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cArraysAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cArraysArrayDeclParserRuleCall_1_0 = (RuleCall)cArraysAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cASSIGNMENTParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cInitAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cInitInitialiserParserRuleCall_2_1_0 = (RuleCall)cInitAssignment_2_1.eContents().get(0);
		
		//DeclId:
		//
		//	name=ID arrays+=ArrayDecl* (ASSIGNMENT init=Initialiser)?;
		public ParserRule getRule() { return rule; }

		//name=ID arrays+=ArrayDecl* (ASSIGNMENT init=Initialiser)?
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//arrays+=ArrayDecl*
		public Assignment getArraysAssignment_1() { return cArraysAssignment_1; }

		//ArrayDecl
		public RuleCall getArraysArrayDeclParserRuleCall_1_0() { return cArraysArrayDeclParserRuleCall_1_0; }

		//(ASSIGNMENT init=Initialiser)?
		public Group getGroup_2() { return cGroup_2; }

		//ASSIGNMENT
		public RuleCall getASSIGNMENTParserRuleCall_2_0() { return cASSIGNMENTParserRuleCall_2_0; }

		//init=Initialiser
		public Assignment getInitAssignment_2_1() { return cInitAssignment_2_1; }

		//Initialiser
		public RuleCall getInitInitialiserParserRuleCall_2_1_0() { return cInitInitialiserParserRuleCall_2_1_0; }
	}

	public class InitialiserElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Initialiser");
		private final Assignment cExprAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cExprBitOrParserRuleCall_0 = (RuleCall)cExprAssignment.eContents().get(0);
		
		//Initialiser:
		//
		//	expr=BitOr;
		public ParserRule getRule() { return rule; }

		//expr=BitOr
		public Assignment getExprAssignment() { return cExprAssignment; }

		//BitOr
		public RuleCall getExprBitOrParserRuleCall_0() { return cExprBitOrParserRuleCall_0; }
	}

	public class ArrayDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArrayDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSizeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSizeINTTerminalRuleCall_1_0 = (RuleCall)cSizeAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		////          |  '{' init+=FieldInit ( ',' init+=FieldInit )* '}' ; // struct not supported
		//
		//// FieldInit : (name=ID ':')? init=Initialiser ;
		//
		//// expression in general
		//
		//ArrayDecl:
		//
		//	"[" size=INT "]";
		public ParserRule getRule() { return rule; }

		//"[" size=INT "]"
		public Group getGroup() { return cGroup; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//size=INT
		public Assignment getSizeAssignment_1() { return cSizeAssignment_1; }

		//INT
		public RuleCall getSizeINTTerminalRuleCall_1_0() { return cSizeINTTerminalRuleCall_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}

	public class BitOrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BitOr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBitXorParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryIntExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpVerticalLineKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBitXorParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// ArgList : {ArgList}  ( args+=BitOr ( ',' args+=BitOr )* )?;
		//
		///// BNF for expressions
		//
		//// ExprList : expr+=Expression ( ',' expr+=Expression )* ;
		//
		/// * =====   Arithmetic expressions ===== * / / * ====== Bitwise operators ======= * / BitOr returns IntExpression:
		//
		//	BitXor ({BinaryIntExpression.left=current} op="|" right=BitXor)*;
		public ParserRule getRule() { return rule; }

		//BitXor ({BinaryIntExpression.left=current} op="|" right=BitXor)*
		public Group getGroup() { return cGroup; }

		//BitXor
		public RuleCall getBitXorParserRuleCall_0() { return cBitXorParserRuleCall_0; }

		//({BinaryIntExpression.left=current} op="|" right=BitXor)*
		public Group getGroup_1() { return cGroup_1; }

		//{BinaryIntExpression.left=current}
		public Action getBinaryIntExpressionLeftAction_1_0() { return cBinaryIntExpressionLeftAction_1_0; }

		//op="|"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"|"
		public Keyword getOpVerticalLineKeyword_1_1_0() { return cOpVerticalLineKeyword_1_1_0; }

		//right=BitXor
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//BitXor
		public RuleCall getRightBitXorParserRuleCall_1_2_0() { return cRightBitXorParserRuleCall_1_2_0; }
	}

	public class BitXorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BitXor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBitAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryIntExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpCircumflexAccentKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBitAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//BitXor returns IntExpression:
		//
		//	BitAnd ({BinaryIntExpression.left=current} op="^" right=BitAnd)*;
		public ParserRule getRule() { return rule; }

		//BitAnd ({BinaryIntExpression.left=current} op="^" right=BitAnd)*
		public Group getGroup() { return cGroup; }

		//BitAnd
		public RuleCall getBitAndParserRuleCall_0() { return cBitAndParserRuleCall_0; }

		//({BinaryIntExpression.left=current} op="^" right=BitAnd)*
		public Group getGroup_1() { return cGroup_1; }

		//{BinaryIntExpression.left=current}
		public Action getBinaryIntExpressionLeftAction_1_0() { return cBinaryIntExpressionLeftAction_1_0; }

		//op="^"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"^"
		public Keyword getOpCircumflexAccentKeyword_1_1_0() { return cOpCircumflexAccentKeyword_1_1_0; }

		//right=BitAnd
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//BitAnd
		public RuleCall getRightBitAndParserRuleCall_1_2_0() { return cRightBitAndParserRuleCall_1_2_0; }
	}

	public class BitAndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BitAnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBitShiftParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryIntExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpAmpersandKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBitShiftParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//BitAnd returns IntExpression:
		//
		//	BitShift ({BinaryIntExpression.left=current} op="&" right=BitShift)*;
		public ParserRule getRule() { return rule; }

		//BitShift ({BinaryIntExpression.left=current} op="&" right=BitShift)*
		public Group getGroup() { return cGroup; }

		//BitShift
		public RuleCall getBitShiftParserRuleCall_0() { return cBitShiftParserRuleCall_0; }

		//({BinaryIntExpression.left=current} op="&" right=BitShift)*
		public Group getGroup_1() { return cGroup_1; }

		//{BinaryIntExpression.left=current}
		public Action getBinaryIntExpressionLeftAction_1_0() { return cBinaryIntExpressionLeftAction_1_0; }

		//op="&"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"&"
		public Keyword getOpAmpersandKeyword_1_1_0() { return cOpAmpersandKeyword_1_1_0; }

		//right=BitShift
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//BitShift
		public RuleCall getRightBitShiftParserRuleCall_1_2_0() { return cRightBitShiftParserRuleCall_1_2_0; }
	}

	public class BitShiftElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BitShift");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryIntExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpLessThanSignLessThanSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpGreaterThanSignGreaterThanSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAdditionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//BitShift returns IntExpression:
		//
		//	Addition ({BinaryIntExpression.left=current} op=("<<" | ">>") right=Addition)*;
		public ParserRule getRule() { return rule; }

		//Addition ({BinaryIntExpression.left=current} op=("<<" | ">>") right=Addition)*
		public Group getGroup() { return cGroup; }

		//Addition
		public RuleCall getAdditionParserRuleCall_0() { return cAdditionParserRuleCall_0; }

		//({BinaryIntExpression.left=current} op=("<<" | ">>") right=Addition)*
		public Group getGroup_1() { return cGroup_1; }

		//{BinaryIntExpression.left=current}
		public Action getBinaryIntExpressionLeftAction_1_0() { return cBinaryIntExpressionLeftAction_1_0; }

		//op=("<<" | ">>")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"<<" | ">>"
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//"<<"
		public Keyword getOpLessThanSignLessThanSignKeyword_1_1_0_0() { return cOpLessThanSignLessThanSignKeyword_1_1_0_0; }

		//">>"
		public Keyword getOpGreaterThanSignGreaterThanSignKeyword_1_1_0_1() { return cOpGreaterThanSignGreaterThanSignKeyword_1_1_0_1; }

		//right=Addition
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Addition
		public RuleCall getRightAdditionParserRuleCall_1_2_0() { return cRightAdditionParserRuleCall_1_2_0; }
	}

	public class AdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Addition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryIntExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpPlusSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpHyphenMinusKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMultiplicationParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Addition returns IntExpression:
		//
		//	Multiplication ({BinaryIntExpression.left=current} op=("+" | "-") right=Multiplication)*;
		public ParserRule getRule() { return rule; }

		//Multiplication ({BinaryIntExpression.left=current} op=("+" | "-") right=Multiplication)*
		public Group getGroup() { return cGroup; }

		//Multiplication
		public RuleCall getMultiplicationParserRuleCall_0() { return cMultiplicationParserRuleCall_0; }

		//({BinaryIntExpression.left=current} op=("+" | "-") right=Multiplication)*
		public Group getGroup_1() { return cGroup_1; }

		//{BinaryIntExpression.left=current}
		public Action getBinaryIntExpressionLeftAction_1_0() { return cBinaryIntExpressionLeftAction_1_0; }

		//op=("+" | "-")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"+" | "-"
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//"+"
		public Keyword getOpPlusSignKeyword_1_1_0_0() { return cOpPlusSignKeyword_1_1_0_0; }

		//"-"
		public Keyword getOpHyphenMinusKeyword_1_1_0_1() { return cOpHyphenMinusKeyword_1_1_0_1; }

		//right=Multiplication
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Multiplication
		public RuleCall getRightMultiplicationParserRuleCall_1_2_0() { return cRightMultiplicationParserRuleCall_1_2_0; }
	}

	public class MultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Multiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBitComplementParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryIntExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpSolidusKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpAsteriskKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Keyword cOpPercentSignKeyword_1_1_0_2 = (Keyword)cOpAlternatives_1_1_0.eContents().get(2);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBitComplementParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Multiplication returns IntExpression:
		//
		//	BitComplement ({BinaryIntExpression.left=current} op=("/" | "*" | "%") right=BitComplement)*;
		public ParserRule getRule() { return rule; }

		//BitComplement ({BinaryIntExpression.left=current} op=("/" | "*" | "%") right=BitComplement)*
		public Group getGroup() { return cGroup; }

		//BitComplement
		public RuleCall getBitComplementParserRuleCall_0() { return cBitComplementParserRuleCall_0; }

		//({BinaryIntExpression.left=current} op=("/" | "*" | "%") right=BitComplement)*
		public Group getGroup_1() { return cGroup_1; }

		//{BinaryIntExpression.left=current}
		public Action getBinaryIntExpressionLeftAction_1_0() { return cBinaryIntExpressionLeftAction_1_0; }

		//op=("/" | "*" | "%")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"/" | "*" | "%"
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//"/"
		public Keyword getOpSolidusKeyword_1_1_0_0() { return cOpSolidusKeyword_1_1_0_0; }

		//"*"
		public Keyword getOpAsteriskKeyword_1_1_0_1() { return cOpAsteriskKeyword_1_1_0_1; }

		//"%"
		public Keyword getOpPercentSignKeyword_1_1_0_2() { return cOpPercentSignKeyword_1_1_0_2; }

		//right=BitComplement
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//BitComplement
		public RuleCall getRightBitComplementParserRuleCall_1_2_0() { return cRightBitComplementParserRuleCall_1_2_0; }
	}

	public class BitComplementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BitComplement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cTildeKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cPowerParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Action cBitComplementValueAction_0_2 = (Action)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cPowerParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Action cUnaryMinusValueAction_1_2 = (Action)cGroup_1.eContents().get(2);
		private final RuleCall cPowerParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//BitComplement returns IntExpression:
		//
		//	"~" Power {BitComplement.value=current} | "-" Power {UnaryMinus.value=current} | Power;
		public ParserRule getRule() { return rule; }

		//"~" Power {BitComplement.value=current} | "-" Power {UnaryMinus.value=current} | Power
		public Alternatives getAlternatives() { return cAlternatives; }

		//"~" Power {BitComplement.value=current}
		public Group getGroup_0() { return cGroup_0; }

		//"~"
		public Keyword getTildeKeyword_0_0() { return cTildeKeyword_0_0; }

		//Power
		public RuleCall getPowerParserRuleCall_0_1() { return cPowerParserRuleCall_0_1; }

		//{BitComplement.value=current}
		public Action getBitComplementValueAction_0_2() { return cBitComplementValueAction_0_2; }

		//"-" Power {UnaryMinus.value=current}
		public Group getGroup_1() { return cGroup_1; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_0() { return cHyphenMinusKeyword_1_0; }

		//Power
		public RuleCall getPowerParserRuleCall_1_1() { return cPowerParserRuleCall_1_1; }

		//{UnaryMinus.value=current}
		public Action getUnaryMinusValueAction_1_2() { return cUnaryMinusValueAction_1_2; }

		//Power
		public RuleCall getPowerParserRuleCall_2() { return cPowerParserRuleCall_2; }
	}

	public class PowerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Power");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryIntExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpAsteriskAsteriskKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Power returns IntExpression:
		//
		//	Primary ({BinaryIntExpression.left=current} op="**" right=Primary)*;
		public ParserRule getRule() { return rule; }

		//Primary ({BinaryIntExpression.left=current} op="**" right=Primary)*
		public Group getGroup() { return cGroup; }

		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }

		//({BinaryIntExpression.left=current} op="**" right=Primary)*
		public Group getGroup_1() { return cGroup_1; }

		//{BinaryIntExpression.left=current}
		public Action getBinaryIntExpressionLeftAction_1_0() { return cBinaryIntExpressionLeftAction_1_0; }

		//op="**"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"**"
		public Keyword getOpAsteriskAsteriskKeyword_1_1_0() { return cOpAsteriskAsteriskKeyword_1_1_0; }

		//right=Primary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Primary
		public RuleCall getRightPrimaryParserRuleCall_1_2_0() { return cRightPrimaryParserRuleCall_1_2_0; }
	}

	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVarAccessParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cConstRefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cAlternatives.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Group cGroup_2_0_0 = (Group)cGroup_2_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2_0_0_0 = (Keyword)cGroup_2_0_0.eContents().get(0);
		private final RuleCall cBitOrParserRuleCall_2_0_0_1 = (RuleCall)cGroup_2_0_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2_0_0_2 = (Keyword)cGroup_2_0_0.eContents().get(2);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final RuleCall cWrapBoolExprParserRuleCall_2_1_1 = (RuleCall)cGroup_2_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2_1_2 = (Keyword)cGroup_2_1.eContents().get(2);
		
		//Primary returns IntExpression:
		//
		//	VarAccess | ConstRef | (=> ("(" BitOr ")") | "(" WrapBoolExpr ")");
		public ParserRule getRule() { return rule; }

		//VarAccess | ConstRef | (=> ("(" BitOr ")") | "(" WrapBoolExpr ")")
		public Alternatives getAlternatives() { return cAlternatives; }

		//VarAccess
		public RuleCall getVarAccessParserRuleCall_0() { return cVarAccessParserRuleCall_0; }

		//ConstRef
		public RuleCall getConstRefParserRuleCall_1() { return cConstRefParserRuleCall_1; }

		//=> ("(" BitOr ")") | "(" WrapBoolExpr ")"
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//=> ("(" BitOr ")")
		public Group getGroup_2_0() { return cGroup_2_0; }

		//"(" BitOr ")"
		public Group getGroup_2_0_0() { return cGroup_2_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_0_0_0() { return cLeftParenthesisKeyword_2_0_0_0; }

		//BitOr
		public RuleCall getBitOrParserRuleCall_2_0_0_1() { return cBitOrParserRuleCall_2_0_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_2_0_0_2() { return cRightParenthesisKeyword_2_0_0_2; }

		//"(" WrapBoolExpr ")"
		public Group getGroup_2_1() { return cGroup_2_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_1_0() { return cLeftParenthesisKeyword_2_1_0; }

		//WrapBoolExpr
		public RuleCall getWrapBoolExprParserRuleCall_2_1_1() { return cWrapBoolExprParserRuleCall_2_1_1; }

		//")"
		public Keyword getRightParenthesisKeyword_2_1_2() { return cRightParenthesisKeyword_2_1_2; }
	}

	public class ConstRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstRef");
		private final RuleCall cConstantParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		////	| 	ParamRef 
		//
		//ConstRef returns IntExpression:
		//
		//	Constant;
		public ParserRule getRule() { return rule; }

		//Constant
		public RuleCall getConstantParserRuleCall() { return cConstantParserRuleCall; }
	}

	public class VarAccessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VarAccess");
		private final Assignment cRefAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cRefFormalDeclarationCrossReference_0 = (CrossReference)cRefAssignment.eContents().get(0);
		private final RuleCall cRefFormalDeclarationIDTerminalRuleCall_0_1 = (RuleCall)cRefFormalDeclarationCrossReference_0.eContents().get(1);
		
		//VarAccess:
		//
		//	ref=[FormalDeclaration];
		public ParserRule getRule() { return rule; }

		//ref=[FormalDeclaration]
		public Assignment getRefAssignment() { return cRefAssignment; }

		//[FormalDeclaration]
		public CrossReference getRefFormalDeclarationCrossReference_0() { return cRefFormalDeclarationCrossReference_0; }

		//ID
		public RuleCall getRefFormalDeclarationIDTerminalRuleCall_0_1() { return cRefFormalDeclarationIDTerminalRuleCall_0_1; }
	}

	public class WrapBoolExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WrapBoolExpr");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueOrParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//// ParamRef : ref=[Parameter];	
		//
		//WrapBoolExpr:
		//
		//	value=Or;
		public ParserRule getRule() { return rule; }

		//value=Or
		public Assignment getValueAssignment() { return cValueAssignment; }

		//Or
		public RuleCall getValueOrParserRuleCall_0() { return cValueOrParserRuleCall_0; }
	}

	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Constant");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Constant:
		//
		//	value=INT;
		public ParserRule getRule() { return rule; }

		//value=INT
		public Assignment getValueAssignment() { return cValueAssignment; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_0() { return cValueINTTerminalRuleCall_0; }
	}

	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Or returns BooleanExpression:
		//
		//	And ({Or.left=current} "||" right=And)*;
		public ParserRule getRule() { return rule; }

		//And ({Or.left=current} "||" right=And)*
		public Group getGroup() { return cGroup; }

		//And
		public RuleCall getAndParserRuleCall_0() { return cAndParserRuleCall_0; }

		//({Or.left=current} "||" right=And)*
		public Group getGroup_1() { return cGroup_1; }

		//{Or.left=current}
		public Action getOrLeftAction_1_0() { return cOrLeftAction_1_0; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1_1() { return cVerticalLineVerticalLineKeyword_1_1; }

		//right=And
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//And
		public RuleCall getRightAndParserRuleCall_1_2_0() { return cRightAndParserRuleCall_1_2_0; }
	}

	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNotParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightNotParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//And returns BooleanExpression:
		//
		//	Not ({And.left=current} "&&" right=Not)*;
		public ParserRule getRule() { return rule; }

		//Not ({And.left=current} "&&" right=Not)*
		public Group getGroup() { return cGroup; }

		//Not
		public RuleCall getNotParserRuleCall_0() { return cNotParserRuleCall_0; }

		//({And.left=current} "&&" right=Not)*
		public Group getGroup_1() { return cGroup_1; }

		//{And.left=current}
		public Action getAndLeftAction_1_0() { return cAndLeftAction_1_0; }

		//"&&"
		public Keyword getAmpersandAmpersandKeyword_1_1() { return cAmpersandAmpersandKeyword_1_1; }

		//right=Not
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Not
		public RuleCall getRightNotParserRuleCall_1_2_0() { return cRightNotParserRuleCall_1_2_0; }
	}

	public class NotElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Not");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Action cNotAction_0_1 = (Action)cGroup_0.eContents().get(1);
		private final Assignment cValueAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cValuePrimaryBoolParserRuleCall_0_2_0 = (RuleCall)cValueAssignment_0_2.eContents().get(0);
		private final RuleCall cPrimaryBoolParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Not returns BooleanExpression:
		//
		//	"!" {Not} value=PrimaryBool | PrimaryBool;
		public ParserRule getRule() { return rule; }

		//"!" {Not} value=PrimaryBool | PrimaryBool
		public Alternatives getAlternatives() { return cAlternatives; }

		//"!" {Not} value=PrimaryBool
		public Group getGroup_0() { return cGroup_0; }

		//"!"
		public Keyword getExclamationMarkKeyword_0_0() { return cExclamationMarkKeyword_0_0; }

		//{Not}
		public Action getNotAction_0_1() { return cNotAction_0_1; }

		//value=PrimaryBool
		public Assignment getValueAssignment_0_2() { return cValueAssignment_0_2; }

		//PrimaryBool
		public RuleCall getValuePrimaryBoolParserRuleCall_0_2_0() { return cValuePrimaryBoolParserRuleCall_0_2_0; }

		//PrimaryBool
		public RuleCall getPrimaryBoolParserRuleCall_1() { return cPrimaryBoolParserRuleCall_1; }
	}

	public class PrimaryBoolElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryBool");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTrueParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFalseParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cComparisonParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final RuleCall cOrParserRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		
		//PrimaryBool returns BooleanExpression:
		//
		//	True | False | => Comparison | "(" Or ")";
		public ParserRule getRule() { return rule; }

		//True | False | => Comparison | "(" Or ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//True
		public RuleCall getTrueParserRuleCall_0() { return cTrueParserRuleCall_0; }

		//False
		public RuleCall getFalseParserRuleCall_1() { return cFalseParserRuleCall_1; }

		//=> Comparison
		public RuleCall getComparisonParserRuleCall_2() { return cComparisonParserRuleCall_2; }

		//"(" Or ")"
		public Group getGroup_3() { return cGroup_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_3_0() { return cLeftParenthesisKeyword_3_0; }

		//Or
		public RuleCall getOrParserRuleCall_3_1() { return cOrParserRuleCall_3_1; }

		//")"
		public Keyword getRightParenthesisKeyword_3_2() { return cRightParenthesisKeyword_3_2; }
	}

	public class ComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Comparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftBitOrParserRuleCall_0_0 = (RuleCall)cLeftAssignment_0.eContents().get(0);
		private final Assignment cOperatorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperatorComparisonOperatorsEnumRuleCall_1_0 = (RuleCall)cOperatorAssignment_1.eContents().get(0);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightBitOrParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		//Comparison:
		//
		//	left=BitOr operator=ComparisonOperators right=BitOr;
		public ParserRule getRule() { return rule; }

		//left=BitOr operator=ComparisonOperators right=BitOr
		public Group getGroup() { return cGroup; }

		//left=BitOr
		public Assignment getLeftAssignment_0() { return cLeftAssignment_0; }

		//BitOr
		public RuleCall getLeftBitOrParserRuleCall_0_0() { return cLeftBitOrParserRuleCall_0_0; }

		//operator=ComparisonOperators
		public Assignment getOperatorAssignment_1() { return cOperatorAssignment_1; }

		//ComparisonOperators
		public RuleCall getOperatorComparisonOperatorsEnumRuleCall_1_0() { return cOperatorComparisonOperatorsEnumRuleCall_1_0; }

		//right=BitOr
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }

		//BitOr
		public RuleCall getRightBitOrParserRuleCall_2_0() { return cRightBitOrParserRuleCall_2_0; }
	}

	public class TrueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "True");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTrueAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTrueKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//True:
		//
		//	{True} "true";
		public ParserRule getRule() { return rule; }

		//{True} "true"
		public Group getGroup() { return cGroup; }

		//{True}
		public Action getTrueAction_0() { return cTrueAction_0; }

		//"true"
		public Keyword getTrueKeyword_1() { return cTrueKeyword_1; }
	}

	public class FalseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "False");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFalseAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//False:
		//
		//	{False} "false";
		public ParserRule getRule() { return rule; }

		//{False} "false"
		public Group getGroup() { return cGroup; }

		//{False}
		public Action getFalseAction_0() { return cFalseAction_0; }

		//"false"
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}

	public class ASSIGNMENTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ASSIGNMENT");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEqualsSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		/// ** Following is version built directly from Grammar * / //
		//
		////Expression : VarRef | Constant | True | False | Call | ArrayRef | PreInc | PostInc | PreDec | PostDec
		//
		////	| AssignExp | UnaryExp | RelExp | BinIntExp | BinBoolExp | TernaryIfExp | QualifiedExp | NestedExp;
		//
		////	
		//
		////VarRef : name=ID ;
		//
		////Constant : value=INT;
		//
		////True : 'true';
		//
		////False : 'false' ;
		//
		////Call : fname=ID '(' args=ArgList ')';
		//
		////ArrayRef : arrname=[ArrayDecl] '[' index=Expression ']';
		//
		////PostIncExp : expr=Expression '++';
		//
		////PreIncExp : '++' expr=Expression ;
		//
		////PostDecExp : expr=Expression '--';
		//
		////PreDecExp : '--' expr=Expression ;
		//
		////UnaryExp: op=UnaryOp expr=Expression ;
		//
		////AssignExp : lhs=Expression op=AssignOp rhs=Expression; 
		//
		////RelExp : lhs=Expression op=Rel rhs=Expression ;
		//
		////BinIntExp : lhs=Expression op=BinIntOp rhs=Expression;
		//
		////BinBoolExp : lhs=Expression op=BinBoolOp rhs=Expression;
		//
		////TernaryIfExp : cond=Expression '?' iftrue=Expression ':' iffalse=Expression ;
		//
		////QualifiedExp : prefix=Expression '.' name=ID ;
		//
		////NestedExp : '(' Expression ')' ;
		//
		////
		//
		////AssignOp : ASSIGNMENT | '+=' | '-=' | '*=' | '/=' | '%='  
		//
		////            | '|=' | '&=' | '^=' | '<<=' | '>>=' ;
		//
		////
		//
		////UnaryOp : '-' | '!' ;
		//
		////
		//
		////Rel : '<' | '<=' | '==' | '!=' | '>=' | '>';
		//
		////BinIntOp : '+' | '-' | '*' | '/' | '%' | '&' | '|' | '^' | '<<' | '>>' ;
		//
		////BinBoolOp : '&&' | '||' ;
		//
		///// BNF for statements, used in Functions only
		//
		////Block : {Block} '{' ( vars+=VariableDecl | types+=TypeDecl )* statements+=Statement* '}' ;
		//
		////
		//
		////
		//
		////Statement : Block | EmptyStatement | ExprStatement 
		//
		////	| ForStatement | WhileStatement | DoStatement 
		//
		////	| ITEStatement | BreakStatement | ContinueStatement
		//
		////	| SwitchStatement | ReturnStatement | ReturnValueStatement ;
		//
		////
		//
		////EmptyStatement :   ';' ;
		//
		////
		//
		////ExprStatement : expr=Expression ';' ;
		//
		////
		//
		////ForStatement :  'for' '(' init=ExprList ';' condition=ExprList ';'  increment=ExprList ')' 
		//
		////	body = Statement ;
		//
		////
		//
		////WhileStatement :  'while' '(' condition=ExprList ')' body=Statement ;
		//
		////
		//
		////DoStatement :  'do' body=Statement 'while' '(' condition=ExprList ')' ';' ;
		//
		////
		//
		////ITEStatement :  'if' '(' condition=ExprList ')' ifbody=Statement 
		//
		////                   ( 'else' elsebody=Statement )? ;
		//
		////
		//
		////BreakStatement : 'break' ';' ;
		//
		////
		//
		////ContinueStatement : 'continue' ';' ;
		//
		////
		//
		////SwitchStatement :  'switch' '(' var=ExprList ')' '{' cases+=Case+ '}' ;
		//
		////
		//
		////ReturnStatement :  'return' ';' ;
		//
		////
		//
		////ReturnValueStatement : 'return' value=Expression ';' ;
		//
		////
		//
		////
		//
		////Case : TestCase | DefaultCase ;
		//
		////TestCase : 'case' value=Expression ':' body+=Statement*  ;
		//
		////DefaultCase : {DefaultCase} ':' body+=Statement* ;
		//
		//ASSIGNMENT: / * new syntax * / "=" | / * old syntax * / ":=";
		public ParserRule getRule() { return rule; }

		/// * new syntax * / "=" | / * old syntax * / ":="
		public Alternatives getAlternatives() { return cAlternatives; }

		/// * new syntax * / "="
		public Keyword getEqualsSignKeyword_0() { return cEqualsSignKeyword_0; }

		/// * old syntax * / ":="
		public Keyword getColonEqualsSignKeyword_1() { return cColonEqualsSignKeyword_1; }
	}
	
	
	public class ComparisonOperatorsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonOperators");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cGTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cGTGreaterThanSignKeyword_0_0 = (Keyword)cGTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLTLessThanSignKeyword_1_0 = (Keyword)cLTEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cGEEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cGEGreaterThanSignEqualsSignKeyword_2_0 = (Keyword)cGEEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLEEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLELessThanSignEqualsSignKeyword_3_0 = (Keyword)cLEEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cEQEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cEQEqualsSignEqualsSignKeyword_4_0 = (Keyword)cEQEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cNEEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cNEExclamationMarkEqualsSignKeyword_5_0 = (Keyword)cNEEnumLiteralDeclaration_5.eContents().get(0);
		
		/// * =====   Boolean expressions ===== * / // Not Equal
		//
		//enum ComparisonOperators:
		//
		//	GT=">" // Greater Thean
		//
		//	// Lower Than
		//
		//	// Greater or Equal
		//
		//	// Lower or Equal
		//
		//	// Equal
		//
		//	| LT="<" | GE=">=" | LE="<=" | EQ="==" | NE="!=";
		public EnumRule getRule() { return rule; }

		//GT=">" // Greater Thean
		//
		//// Lower Than
		//
		//// Greater or Equal
		//
		//// Lower or Equal
		//
		//// Equal
		//
		//| LT="<" | GE=">=" | LE="<=" | EQ="==" | NE="!="
		public Alternatives getAlternatives() { return cAlternatives; }

		//GT=">"
		public EnumLiteralDeclaration getGTEnumLiteralDeclaration_0() { return cGTEnumLiteralDeclaration_0; }

		//">"
		public Keyword getGTGreaterThanSignKeyword_0_0() { return cGTGreaterThanSignKeyword_0_0; }

		//LT="<"
		public EnumLiteralDeclaration getLTEnumLiteralDeclaration_1() { return cLTEnumLiteralDeclaration_1; }

		//"<"
		public Keyword getLTLessThanSignKeyword_1_0() { return cLTLessThanSignKeyword_1_0; }

		//GE=">="
		public EnumLiteralDeclaration getGEEnumLiteralDeclaration_2() { return cGEEnumLiteralDeclaration_2; }

		//">="
		public Keyword getGEGreaterThanSignEqualsSignKeyword_2_0() { return cGEGreaterThanSignEqualsSignKeyword_2_0; }

		//LE="<="
		public EnumLiteralDeclaration getLEEnumLiteralDeclaration_3() { return cLEEnumLiteralDeclaration_3; }

		//"<="
		public Keyword getLELessThanSignEqualsSignKeyword_3_0() { return cLELessThanSignEqualsSignKeyword_3_0; }

		//EQ="=="
		public EnumLiteralDeclaration getEQEnumLiteralDeclaration_4() { return cEQEnumLiteralDeclaration_4; }

		//"=="
		public Keyword getEQEqualsSignEqualsSignKeyword_4_0() { return cEQEqualsSignEqualsSignKeyword_4_0; }

		//NE="!="
		public EnumLiteralDeclaration getNEEnumLiteralDeclaration_5() { return cNEEnumLiteralDeclaration_5; }

		//"!="
		public Keyword getNEExclamationMarkEqualsSignKeyword_5_0() { return cNEExclamationMarkEqualsSignKeyword_5_0; }
	}
	
	private XTAElements pXTA;
	private InstantiableInSystemElements pInstantiableInSystem;
	private InstanceElements pInstance;
	private SystemElements pSystem;
	private ProcDeclElements pProcDecl;
	private FormalDeclarationElements pFormalDeclaration;
	private ParameterElements pParameter;
	private TypeDeclElements pTypeDecl;
	private TypeElements pType;
	private BasicTypeElements pBasicType;
	private TypedefRefElements pTypedefRef;
	private ChannelDeclElements pChannelDecl;
	private ChanIdElements pChanId;
	private ChannelTypeElements pChannelType;
	private IntegerTypeElements pIntegerType;
	private BoolTypeElements pBoolType;
	private RangeTypeElements pRangeType;
	private ClockTypeElements pClockType;
	private ProcBodyElements pProcBody;
	private StateDeclElements pStateDecl;
	private TransitionElements pTransition;
	private SyncElements pSync;
	private SendElements pSend;
	private RecvElements pRecv;
	private AssignmentsElements pAssignments;
	private AssignElements pAssign;
	private VariableDeclElements pVariableDecl;
	private DeclIdElements pDeclId;
	private InitialiserElements pInitialiser;
	private ArrayDeclElements pArrayDecl;
	private BitOrElements pBitOr;
	private BitXorElements pBitXor;
	private BitAndElements pBitAnd;
	private BitShiftElements pBitShift;
	private AdditionElements pAddition;
	private MultiplicationElements pMultiplication;
	private BitComplementElements pBitComplement;
	private PowerElements pPower;
	private PrimaryElements pPrimary;
	private ConstRefElements pConstRef;
	private VarAccessElements pVarAccess;
	private WrapBoolExprElements pWrapBoolExpr;
	private ConstantElements pConstant;
	private ComparisonOperatorsElements unknownRuleComparisonOperators;
	private OrElements pOr;
	private AndElements pAnd;
	private NotElements pNot;
	private PrimaryBoolElements pPrimaryBool;
	private ComparisonElements pComparison;
	private TrueElements pTrue;
	private FalseElements pFalse;
	private ASSIGNMENTElements pASSIGNMENT;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public TimedAutomataGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("fr.lip6.move.TimedAutomata".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//XTA:
	//
	//	(variables+=VariableDecl | channels+=ChannelDecl | types+=TypeDecl | templates+=ProcDecl)* instances+=Instance*
	//
	//	system=System;
	public XTAElements getXTAAccess() {
		return (pXTA != null) ? pXTA : (pXTA = new XTAElements());
	}
	
	public ParserRule getXTARule() {
		return getXTAAccess().getRule();
	}

	////Declaration :
	//
	////// Functions are not supported yet.
	//
	//////	FunctionDecl | 
	//
	////	VariableDecl | ChannelDecl | TypeDecl | ProcDecl ;
	//
	//InstantiableInSystem:
	//
	//	Instance | ProcDecl;
	public InstantiableInSystemElements getInstantiableInSystemAccess() {
		return (pInstantiableInSystem != null) ? pInstantiableInSystem : (pInstantiableInSystem = new InstantiableInSystemElements());
	}
	
	public ParserRule getInstantiableInSystemRule() {
		return getInstantiableInSystemAccess().getRule();
	}

	//Instance:
	//
	//	name=ID ASSIGNMENT type=[ProcDecl] "(" (args+=BitOr ("," args+=BitOr)*)? ")" ";";
	public InstanceElements getInstanceAccess() {
		return (pInstance != null) ? pInstance : (pInstance = new InstanceElements());
	}
	
	public ParserRule getInstanceRule() {
		return getInstanceAccess().getRule();
	}

	//System:
	//
	//	"system" instances+=[InstantiableInSystem] ("," instances+=[InstantiableInSystem])* ";";
	public SystemElements getSystemAccess() {
		return (pSystem != null) ? pSystem : (pSystem = new SystemElements());
	}
	
	public ParserRule getSystemRule() {
		return getSystemAccess().getRule();
	}

	//// FunctionDecl : type=Type name=ID (params=ParameterList) block=Block ;
	//
	//ProcDecl:
	//
	//	"process" name=ID "(" (params+=Parameter ("," params+=Parameter)*)? ")" "{" body=ProcBody "}";
	public ProcDeclElements getProcDeclAccess() {
		return (pProcDecl != null) ? pProcDecl : (pProcDecl = new ProcDeclElements());
	}
	
	public ParserRule getProcDeclRule() {
		return getProcDeclAccess().getRule();
	}

	//FormalDeclaration:
	//
	//	Parameter | DeclId;
	public FormalDeclarationElements getFormalDeclarationAccess() {
		return (pFormalDeclaration != null) ? pFormalDeclaration : (pFormalDeclaration = new FormalDeclarationElements());
	}
	
	public ParserRule getFormalDeclarationRule() {
		return getFormalDeclarationAccess().getRule();
	}

	//// (vals+=ArrayDecl)* // not sure what this is about, no example in doc.
	//
	//Parameter:
	//
	//	type=Type //	('&')?  // call by reference is not supported as we do macro substitute for constant parameters only
	//
	//	name=ID;
	public ParameterElements getParameterAccess() {
		return (pParameter != null) ? pParameter : (pParameter = new ParameterElements());
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}

	//TypeDecl:
	//
	//	"typedef" type=Type name=ID // (',' ids+=TypeIdList)*  // We only support one typedef at a time.
	//
	//	";";
	public TypeDeclElements getTypeDeclAccess() {
		return (pTypeDecl != null) ? pTypeDecl : (pTypeDecl = new TypeDeclElements());
	}
	
	public ParserRule getTypeDeclRule() {
		return getTypeDeclAccess().getRule();
	}

	//Type:
	//
	//	BasicType | TypedefRef;
	public TypeElements getTypeAccess() {
		return (pType != null) ? pType : (pType = new TypeElements());
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	//// or struct
	//
	//BasicType:
	//
	//	IntegerType | BoolType | ClockType | RangeType;
	public BasicTypeElements getBasicTypeAccess() {
		return (pBasicType != null) ? pBasicType : (pBasicType = new BasicTypeElements());
	}
	
	public ParserRule getBasicTypeRule() {
		return getBasicTypeAccess().getRule();
	}

	//// ChannelType |
	//
	//TypedefRef:
	//
	//	ref=[TypeDecl];
	public TypedefRefElements getTypedefRefAccess() {
		return (pTypedefRef != null) ? pTypedefRef : (pTypedefRef = new TypedefRefElements());
	}
	
	public ParserRule getTypedefRefRule() {
		return getTypedefRefAccess().getRule();
	}

	//ChannelDecl:
	//
	//	ChannelType chans+=ChanId ("," chans+=ChanId)* ";";
	public ChannelDeclElements getChannelDeclAccess() {
		return (pChannelDecl != null) ? pChannelDecl : (pChannelDecl = new ChannelDeclElements());
	}
	
	public ParserRule getChannelDeclRule() {
		return getChannelDeclAccess().getRule();
	}

	//ChanId:
	//
	//	name=ID;
	public ChanIdElements getChanIdAccess() {
		return (pChanId != null) ? pChanId : (pChanId = new ChanIdElements());
	}
	
	public ParserRule getChanIdRule() {
		return getChanIdAccess().getRule();
	}

	//ChannelType:
	//
	//	{ChannelType} "chan" urgent?="urgent"? broadcast?="broadcast"?;
	public ChannelTypeElements getChannelTypeAccess() {
		return (pChannelType != null) ? pChannelType : (pChannelType = new ChannelTypeElements());
	}
	
	public ParserRule getChannelTypeRule() {
		return getChannelTypeAccess().getRule();
	}

	//IntegerType:
	//
	//	{IntegerType} const?="const"? "int";
	public IntegerTypeElements getIntegerTypeAccess() {
		return (pIntegerType != null) ? pIntegerType : (pIntegerType = new IntegerTypeElements());
	}
	
	public ParserRule getIntegerTypeRule() {
		return getIntegerTypeAccess().getRule();
	}

	//BoolType:
	//
	//	{BoolType} const?="const"? "bool";
	public BoolTypeElements getBoolTypeAccess() {
		return (pBoolType != null) ? pBoolType : (pBoolType = new BoolTypeElements());
	}
	
	public ParserRule getBoolTypeRule() {
		return getBoolTypeAccess().getRule();
	}

	//// these INT should be expressions in general
	//
	//RangeType:
	//
	//	const?="const"? "int" "[" min=INT "," max=INT "]";
	public RangeTypeElements getRangeTypeAccess() {
		return (pRangeType != null) ? pRangeType : (pRangeType = new RangeTypeElements());
	}
	
	public ParserRule getRangeTypeRule() {
		return getRangeTypeAccess().getRule();
	}

	//ClockType:
	//
	//	{ClockType} "clock";
	public ClockTypeElements getClockTypeAccess() {
		return (pClockType != null) ? pClockType : (pClockType = new ClockTypeElements());
	}
	
	public ParserRule getClockTypeRule() {
		return getClockTypeAccess().getRule();
	}

	//// struct declarations not supported yet
	//
	////     |  prefix=Prefix 'struct' '{' fields+=FieldDecl+ '}' 
	//
	//// structs are not supported
	//
	//// FieldDecl : type=Type ids+=FieldDeclId (',' ids+=FieldDeclId)* ';' ;
	//
	////    
	//
	//// FieldDeclId : name=ID arrays+=ArrayDecl* ;
	//
	//ProcBody: // functions are not supported yet
	//
	//// functions+=FunctionDecl | 
	//
	//	(variables+=VariableDecl | types+=TypeDecl)* "state" states+=StateDecl ("," states+=StateDecl)* ";" ("commit"
	//
	//	commitStates+=[StateDecl] ("," commitStates+=[StateDecl])* ";")? ("urgent" urgentStates+=[StateDecl] (","
	//
	//	urgentStates+=[StateDecl])* ";")? "init" initState=[StateDecl] ";" ("trans" transitions+=Transition (","
	//
	//	transitions+=Transition)* ";");
	public ProcBodyElements getProcBodyAccess() {
		return (pProcBody != null) ? pProcBody : (pProcBody = new ProcBodyElements());
	}
	
	public ParserRule getProcBodyRule() {
		return getProcBodyAccess().getRule();
	}

	//StateDecl:
	//
	//	name=ID ("{" invariant=Or "}")?;
	public StateDeclElements getStateDeclAccess() {
		return (pStateDecl != null) ? pStateDecl : (pStateDecl = new StateDeclElements());
	}
	
	public ParserRule getStateDeclRule() {
		return getStateDeclAccess().getRule();
	}

	//Transition:
	//
	//	src=[StateDecl] "->" dest=[StateDecl] "{" ("guard" guard=Or ";")? sync=Sync? assign=Assignments? "}";
	public TransitionElements getTransitionAccess() {
		return (pTransition != null) ? pTransition : (pTransition = new TransitionElements());
	}
	
	public ParserRule getTransitionRule() {
		return getTransitionAccess().getRule();
	}

	//// ignore this feature of many outgoing edges, it doesn(t appear in the examples
	//
	//// TransitionOpt : Transition | '->' dest=[StateDecl] body=TransitionBody ;
	//
	//Sync:
	//
	//	Send | Recv;
	public SyncElements getSyncAccess() {
		return (pSync != null) ? pSync : (pSync = new SyncElements());
	}
	
	public ParserRule getSyncRule() {
		return getSyncAccess().getRule();
	}

	//// we need a ChannelDecl metaclass to force correct usage
	//
	//Send:
	//
	//	"sync" channel=[ChanId] "!" ";";
	public SendElements getSendAccess() {
		return (pSend != null) ? pSend : (pSend = new SendElements());
	}
	
	public ParserRule getSendRule() {
		return getSendAccess().getRule();
	}

	//Recv:
	//
	//	"sync" channel=[ChanId] "?" ";";
	public RecvElements getRecvAccess() {
		return (pRecv != null) ? pRecv : (pRecv = new RecvElements());
	}
	
	public ParserRule getRecvRule() {
		return getRecvAccess().getRule();
	}

	//Assignments:
	//
	//	"assign" assigns+=Assign ("," assigns+=Assign)* ";";
	public AssignmentsElements getAssignmentsAccess() {
		return (pAssignments != null) ? pAssignments : (pAssignments = new AssignmentsElements());
	}
	
	public ParserRule getAssignmentsRule() {
		return getAssignmentsAccess().getRule();
	}

	//Assign:
	//
	//	lhs=VarAccess ASSIGNMENT rhs=BitOr;
	public AssignElements getAssignAccess() {
		return (pAssign != null) ? pAssign : (pAssign = new AssignElements());
	}
	
	public ParserRule getAssignRule() {
		return getAssignAccess().getRule();
	}

	//// TypeIdList : name=ID arrays+=ArrayDecl* ;
	//
	///// BNF for variable declarations
	//
	//VariableDecl:
	//
	//	type=BasicType declid+=DeclId ("," declid+=DeclId)* ";";
	public VariableDeclElements getVariableDeclAccess() {
		return (pVariableDecl != null) ? pVariableDecl : (pVariableDecl = new VariableDeclElements());
	}
	
	public ParserRule getVariableDeclRule() {
		return getVariableDeclAccess().getRule();
	}

	//DeclId:
	//
	//	name=ID arrays+=ArrayDecl* (ASSIGNMENT init=Initialiser)?;
	public DeclIdElements getDeclIdAccess() {
		return (pDeclId != null) ? pDeclId : (pDeclId = new DeclIdElements());
	}
	
	public ParserRule getDeclIdRule() {
		return getDeclIdAccess().getRule();
	}

	//Initialiser:
	//
	//	expr=BitOr;
	public InitialiserElements getInitialiserAccess() {
		return (pInitialiser != null) ? pInitialiser : (pInitialiser = new InitialiserElements());
	}
	
	public ParserRule getInitialiserRule() {
		return getInitialiserAccess().getRule();
	}

	////          |  '{' init+=FieldInit ( ',' init+=FieldInit )* '}' ; // struct not supported
	//
	//// FieldInit : (name=ID ':')? init=Initialiser ;
	//
	//// expression in general
	//
	//ArrayDecl:
	//
	//	"[" size=INT "]";
	public ArrayDeclElements getArrayDeclAccess() {
		return (pArrayDecl != null) ? pArrayDecl : (pArrayDecl = new ArrayDeclElements());
	}
	
	public ParserRule getArrayDeclRule() {
		return getArrayDeclAccess().getRule();
	}

	//// ArgList : {ArgList}  ( args+=BitOr ( ',' args+=BitOr )* )?;
	//
	///// BNF for expressions
	//
	//// ExprList : expr+=Expression ( ',' expr+=Expression )* ;
	//
	/// * =====   Arithmetic expressions ===== * / / * ====== Bitwise operators ======= * / BitOr returns IntExpression:
	//
	//	BitXor ({BinaryIntExpression.left=current} op="|" right=BitXor)*;
	public BitOrElements getBitOrAccess() {
		return (pBitOr != null) ? pBitOr : (pBitOr = new BitOrElements());
	}
	
	public ParserRule getBitOrRule() {
		return getBitOrAccess().getRule();
	}

	//BitXor returns IntExpression:
	//
	//	BitAnd ({BinaryIntExpression.left=current} op="^" right=BitAnd)*;
	public BitXorElements getBitXorAccess() {
		return (pBitXor != null) ? pBitXor : (pBitXor = new BitXorElements());
	}
	
	public ParserRule getBitXorRule() {
		return getBitXorAccess().getRule();
	}

	//BitAnd returns IntExpression:
	//
	//	BitShift ({BinaryIntExpression.left=current} op="&" right=BitShift)*;
	public BitAndElements getBitAndAccess() {
		return (pBitAnd != null) ? pBitAnd : (pBitAnd = new BitAndElements());
	}
	
	public ParserRule getBitAndRule() {
		return getBitAndAccess().getRule();
	}

	//BitShift returns IntExpression:
	//
	//	Addition ({BinaryIntExpression.left=current} op=("<<" | ">>") right=Addition)*;
	public BitShiftElements getBitShiftAccess() {
		return (pBitShift != null) ? pBitShift : (pBitShift = new BitShiftElements());
	}
	
	public ParserRule getBitShiftRule() {
		return getBitShiftAccess().getRule();
	}

	//Addition returns IntExpression:
	//
	//	Multiplication ({BinaryIntExpression.left=current} op=("+" | "-") right=Multiplication)*;
	public AdditionElements getAdditionAccess() {
		return (pAddition != null) ? pAddition : (pAddition = new AdditionElements());
	}
	
	public ParserRule getAdditionRule() {
		return getAdditionAccess().getRule();
	}

	//Multiplication returns IntExpression:
	//
	//	BitComplement ({BinaryIntExpression.left=current} op=("/" | "*" | "%") right=BitComplement)*;
	public MultiplicationElements getMultiplicationAccess() {
		return (pMultiplication != null) ? pMultiplication : (pMultiplication = new MultiplicationElements());
	}
	
	public ParserRule getMultiplicationRule() {
		return getMultiplicationAccess().getRule();
	}

	//BitComplement returns IntExpression:
	//
	//	"~" Power {BitComplement.value=current} | "-" Power {UnaryMinus.value=current} | Power;
	public BitComplementElements getBitComplementAccess() {
		return (pBitComplement != null) ? pBitComplement : (pBitComplement = new BitComplementElements());
	}
	
	public ParserRule getBitComplementRule() {
		return getBitComplementAccess().getRule();
	}

	//Power returns IntExpression:
	//
	//	Primary ({BinaryIntExpression.left=current} op="**" right=Primary)*;
	public PowerElements getPowerAccess() {
		return (pPower != null) ? pPower : (pPower = new PowerElements());
	}
	
	public ParserRule getPowerRule() {
		return getPowerAccess().getRule();
	}

	//Primary returns IntExpression:
	//
	//	VarAccess | ConstRef | (=> ("(" BitOr ")") | "(" WrapBoolExpr ")");
	public PrimaryElements getPrimaryAccess() {
		return (pPrimary != null) ? pPrimary : (pPrimary = new PrimaryElements());
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}

	////	| 	ParamRef 
	//
	//ConstRef returns IntExpression:
	//
	//	Constant;
	public ConstRefElements getConstRefAccess() {
		return (pConstRef != null) ? pConstRef : (pConstRef = new ConstRefElements());
	}
	
	public ParserRule getConstRefRule() {
		return getConstRefAccess().getRule();
	}

	//VarAccess:
	//
	//	ref=[FormalDeclaration];
	public VarAccessElements getVarAccessAccess() {
		return (pVarAccess != null) ? pVarAccess : (pVarAccess = new VarAccessElements());
	}
	
	public ParserRule getVarAccessRule() {
		return getVarAccessAccess().getRule();
	}

	//// ParamRef : ref=[Parameter];	
	//
	//WrapBoolExpr:
	//
	//	value=Or;
	public WrapBoolExprElements getWrapBoolExprAccess() {
		return (pWrapBoolExpr != null) ? pWrapBoolExpr : (pWrapBoolExpr = new WrapBoolExprElements());
	}
	
	public ParserRule getWrapBoolExprRule() {
		return getWrapBoolExprAccess().getRule();
	}

	//Constant:
	//
	//	value=INT;
	public ConstantElements getConstantAccess() {
		return (pConstant != null) ? pConstant : (pConstant = new ConstantElements());
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}

	/// * =====   Boolean expressions ===== * / // Not Equal
	//
	//enum ComparisonOperators:
	//
	//	GT=">" // Greater Thean
	//
	//	// Lower Than
	//
	//	// Greater or Equal
	//
	//	// Lower or Equal
	//
	//	// Equal
	//
	//	| LT="<" | GE=">=" | LE="<=" | EQ="==" | NE="!=";
	public ComparisonOperatorsElements getComparisonOperatorsAccess() {
		return (unknownRuleComparisonOperators != null) ? unknownRuleComparisonOperators : (unknownRuleComparisonOperators = new ComparisonOperatorsElements());
	}
	
	public EnumRule getComparisonOperatorsRule() {
		return getComparisonOperatorsAccess().getRule();
	}

	//Or returns BooleanExpression:
	//
	//	And ({Or.left=current} "||" right=And)*;
	public OrElements getOrAccess() {
		return (pOr != null) ? pOr : (pOr = new OrElements());
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}

	//And returns BooleanExpression:
	//
	//	Not ({And.left=current} "&&" right=Not)*;
	public AndElements getAndAccess() {
		return (pAnd != null) ? pAnd : (pAnd = new AndElements());
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}

	//Not returns BooleanExpression:
	//
	//	"!" {Not} value=PrimaryBool | PrimaryBool;
	public NotElements getNotAccess() {
		return (pNot != null) ? pNot : (pNot = new NotElements());
	}
	
	public ParserRule getNotRule() {
		return getNotAccess().getRule();
	}

	//PrimaryBool returns BooleanExpression:
	//
	//	True | False | => Comparison | "(" Or ")";
	public PrimaryBoolElements getPrimaryBoolAccess() {
		return (pPrimaryBool != null) ? pPrimaryBool : (pPrimaryBool = new PrimaryBoolElements());
	}
	
	public ParserRule getPrimaryBoolRule() {
		return getPrimaryBoolAccess().getRule();
	}

	//Comparison:
	//
	//	left=BitOr operator=ComparisonOperators right=BitOr;
	public ComparisonElements getComparisonAccess() {
		return (pComparison != null) ? pComparison : (pComparison = new ComparisonElements());
	}
	
	public ParserRule getComparisonRule() {
		return getComparisonAccess().getRule();
	}

	//True:
	//
	//	{True} "true";
	public TrueElements getTrueAccess() {
		return (pTrue != null) ? pTrue : (pTrue = new TrueElements());
	}
	
	public ParserRule getTrueRule() {
		return getTrueAccess().getRule();
	}

	//False:
	//
	//	{False} "false";
	public FalseElements getFalseAccess() {
		return (pFalse != null) ? pFalse : (pFalse = new FalseElements());
	}
	
	public ParserRule getFalseRule() {
		return getFalseAccess().getRule();
	}

	/// ** Following is version built directly from Grammar * / //
	//
	////Expression : VarRef | Constant | True | False | Call | ArrayRef | PreInc | PostInc | PreDec | PostDec
	//
	////	| AssignExp | UnaryExp | RelExp | BinIntExp | BinBoolExp | TernaryIfExp | QualifiedExp | NestedExp;
	//
	////	
	//
	////VarRef : name=ID ;
	//
	////Constant : value=INT;
	//
	////True : 'true';
	//
	////False : 'false' ;
	//
	////Call : fname=ID '(' args=ArgList ')';
	//
	////ArrayRef : arrname=[ArrayDecl] '[' index=Expression ']';
	//
	////PostIncExp : expr=Expression '++';
	//
	////PreIncExp : '++' expr=Expression ;
	//
	////PostDecExp : expr=Expression '--';
	//
	////PreDecExp : '--' expr=Expression ;
	//
	////UnaryExp: op=UnaryOp expr=Expression ;
	//
	////AssignExp : lhs=Expression op=AssignOp rhs=Expression; 
	//
	////RelExp : lhs=Expression op=Rel rhs=Expression ;
	//
	////BinIntExp : lhs=Expression op=BinIntOp rhs=Expression;
	//
	////BinBoolExp : lhs=Expression op=BinBoolOp rhs=Expression;
	//
	////TernaryIfExp : cond=Expression '?' iftrue=Expression ':' iffalse=Expression ;
	//
	////QualifiedExp : prefix=Expression '.' name=ID ;
	//
	////NestedExp : '(' Expression ')' ;
	//
	////
	//
	////AssignOp : ASSIGNMENT | '+=' | '-=' | '*=' | '/=' | '%='  
	//
	////            | '|=' | '&=' | '^=' | '<<=' | '>>=' ;
	//
	////
	//
	////UnaryOp : '-' | '!' ;
	//
	////
	//
	////Rel : '<' | '<=' | '==' | '!=' | '>=' | '>';
	//
	////BinIntOp : '+' | '-' | '*' | '/' | '%' | '&' | '|' | '^' | '<<' | '>>' ;
	//
	////BinBoolOp : '&&' | '||' ;
	//
	///// BNF for statements, used in Functions only
	//
	////Block : {Block} '{' ( vars+=VariableDecl | types+=TypeDecl )* statements+=Statement* '}' ;
	//
	////
	//
	////
	//
	////Statement : Block | EmptyStatement | ExprStatement 
	//
	////	| ForStatement | WhileStatement | DoStatement 
	//
	////	| ITEStatement | BreakStatement | ContinueStatement
	//
	////	| SwitchStatement | ReturnStatement | ReturnValueStatement ;
	//
	////
	//
	////EmptyStatement :   ';' ;
	//
	////
	//
	////ExprStatement : expr=Expression ';' ;
	//
	////
	//
	////ForStatement :  'for' '(' init=ExprList ';' condition=ExprList ';'  increment=ExprList ')' 
	//
	////	body = Statement ;
	//
	////
	//
	////WhileStatement :  'while' '(' condition=ExprList ')' body=Statement ;
	//
	////
	//
	////DoStatement :  'do' body=Statement 'while' '(' condition=ExprList ')' ';' ;
	//
	////
	//
	////ITEStatement :  'if' '(' condition=ExprList ')' ifbody=Statement 
	//
	////                   ( 'else' elsebody=Statement )? ;
	//
	////
	//
	////BreakStatement : 'break' ';' ;
	//
	////
	//
	////ContinueStatement : 'continue' ';' ;
	//
	////
	//
	////SwitchStatement :  'switch' '(' var=ExprList ')' '{' cases+=Case+ '}' ;
	//
	////
	//
	////ReturnStatement :  'return' ';' ;
	//
	////
	//
	////ReturnValueStatement : 'return' value=Expression ';' ;
	//
	////
	//
	////
	//
	////Case : TestCase | DefaultCase ;
	//
	////TestCase : 'case' value=Expression ':' body+=Statement*  ;
	//
	////DefaultCase : {DefaultCase} ':' body+=Statement* ;
	//
	//ASSIGNMENT: / * new syntax * / "=" | / * old syntax * / ":=";
	public ASSIGNMENTElements getASSIGNMENTAccess() {
		return (pASSIGNMENT != null) ? pASSIGNMENT : (pASSIGNMENT = new ASSIGNMENTElements());
	}
	
	public ParserRule getASSIGNMENTRule() {
		return getASSIGNMENTAccess().getRule();
	}

	//terminal ID:
	//
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
