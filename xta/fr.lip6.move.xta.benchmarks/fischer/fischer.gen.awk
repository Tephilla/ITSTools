#!/usr/bin/awk -f 
## #############################################################
## Generates fischer n
## #############################################################
## writes files
##  fischer_input_XX_YY.ta
##  fischer_input_XX_YY.q
##  
##  where XX is a two-digit decimal for n
##  where YY is a two-digit decimal for k
## #############################################################
## 
## Synopsis:
##  Finding good switch settings for UML-2001 paper :o)
## #############################################################
## @FILE:    generate.awk
## @PLACE:   BRICS AArhus; host:harald
## @FORMAT:  awk
## @AUTHOR:  M. Oliver M'o'ller     <omoeller@brics.dk>
## @BEGUN:   Wed Sep 12 20:44:41 2001
## @VERSION: Fri Sep 14 09:40:37 2001
## #############################################################
## 

## ###################################################################
## Disclaimer
## ###################################################################

function disclaimer(i, k, OUT){
    #ret=time[1];
    #ret=time["second"];
    #ret = strftime("%a %b %d %H:%M:%S %Z %Y");
    print "// ------------------------------------------------------------ "  > OUT;
    print "// Fischer " i k > OUT;
    print "// " > OUT;
    print "// automatically generated by script generate.awk "  > OUT;
    print "// M. Oliver Moeller <omoeller@brics.dk> "  > OUT;
    print "// Wed Sep 12 20:44:41 2001 "  > OUT;
    print "// ------------------------------------------------------------ "  > OUT;
}



function clocks(i, k, OUT){
   print "typedef int[1," i "] id_t;\n" > OUT;
    ORS="" ;
#     print "clock " > OUT;
#     for(v = 1; v <= i; v++){
# 	print "x" v  > OUT;
# 	if(v < i){ print ", "  > OUT; }
#     }
#     print ";\n"  > OUT;
    print "int id;\n"  > OUT;
    print "const int k = " k ";\n"  > OUT;
    print "\n"  > OUT;
    ORS="\n";
}

function systemdef(i, k, OUT){
    ORS="" ;
    print "system P" > OUT;
#     for(v = 1; v <= i; v++){
# 	print "p" v  > OUT;
# 	if(v < i){ print ", "  > OUT; }
#     }
    print ";\n"  > OUT;
    print "\n"  > OUT;
    ORS="\n";
}

function process(i, k, OUT){
    print "process P(id_t pid) {" > OUT;
    print "  clock x;\n" > OUT;
    print "  state  a, b {x<=k}, c, cs;" > OUT;
    print "  init   a;" > OUT;
    print "  trans  a -> b {" > OUT;
    print "           guard  id==0;" > OUT;
    print "           assign x:=0;" > OUT;
    print "         }," > OUT;
    print "           b -> c {" > OUT;
    print "           guard  x<=k;" > OUT;
    print "           assign x:=0,id:=pid;" > OUT;
    print "         }," > OUT;
    print "           c -> b {" > OUT;
    print "           guard  id==0;" > OUT;
    print "           assign x:=0;" > OUT;
    print "         }," > OUT;
    print "           c -> cs {" > OUT;
    print "           guard  x>k && id==pid;" > OUT;
    print "         }," > OUT;
    print "           cs -> a {" > OUT;
    print "           assign x:=0,id:=0;" > OUT;
    print "         };" > OUT;
    print "}" > OUT;
    print "" > OUT;
}


function mutex(i, k, OUT){
    ORS="" ;
    print "A[] not (" > OUT;
    for(v = 2; v <= i; v++){
	print "(P(" v ").cs and (" > OUT;
	for (w = 1; w < v; w++){
	    print "P(" w ").cs" > OUT;
	    if(w+1 < v){ print " or " > OUT ; }
	}
	print "))"> OUT ;
	if(v < i){ print " or "> OUT ; }
    }
    print " )\n"> OUT ;
    ORS="\n";
}

function mutexgal(i, k, OUT) {
    ORS="" ;
    for(v = 2; v <= i; v++){
	print "(Pstate[" v-1 "] == 3 && (" > OUT;
	for (w = 1; w < v; w++){
	    print "Pstate[" w-1 "] == 3" > OUT;
	    if(w+1 < v){ print " || " > OUT ; }
	}
	print "))"> OUT ;
	if(v < i){ print " || "> OUT ; }
    }
    print "\n"> OUT ;
    ORS="\n";
}

BEGIN {
  if(ARGC!=3) {
    print "wrong number of arguments" | "cat 1>&2";
    exit(1);
  }
 N = ARGV[1] + 0;
 K = ARGV[2] + 0;

 print "** " N    ;
  if(N<=0) {
    print "*** non valid `N' (use option -vN=# )" | "cat 1>&2"
    exit 1
  }
#  printf "%02d\n", N;
## -- set output names ------------------------------------------
  if( N >= 10 ) { 
      OUTPUT_Q =("fischer_input_" N "_" K ".q"); 
      OUTPUT_TA=("fischer_input_" N "_" K ".xta");
      OUTPUT_REACH=("fischer_input_" N "_" K ".reach");
  }
  else {
      OUTPUT_Q =("fischer_input_0" N "_" K ".q");
      OUTPUT_TA=("fischer_input_0" N "_" K ".xta");
      OUTPUT_REACH=("fischer_input_0" N "_" K ".reach");
  }
## -- generate .ta ---------------------------------------------------------
  disclaimer(N, K, OUTPUT_TA);
  clocks(N, K, OUTPUT_TA);
#   for(v = 1; v <= N; v++){
      process(N, K, OUTPUT_TA);
#   }
  systemdef(N,K,OUTPUT_TA);
## -- generate .q ----------------------------------------------------------
  mutex(N, K, OUTPUT_Q);
## -- generate .reach ------------------------------------------------------
  mutexgal(N, K, OUTPUT_REACH);
## -------------------------------------------------------------------------
  close(OUTPUT_TA);
  close(OUTPUT_Q);
}
